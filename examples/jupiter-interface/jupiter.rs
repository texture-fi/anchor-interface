macro_rules ! gen_crate_docs {() => {concat ! (" " , "Jupiter" , " v" , "0.1.0" , " program interface generated from Anchor IDL.")}} pub use anchor_interface :: prelude :: * ; pub mod instruction {# [allow (unused_imports)] use crate :: types :: * ; # [derive (Debug)] pub enum JupiterInstruction {# [doc = " Route"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` token program"] # [doc = " 1. `[signer]` user transfer authority"] # [doc = " 2. `[]` destination token account"] Route {swap_leg : SwapLeg , in_amount : u64 , quoted_out_amount : u64 , slippage_bps : u16 , platform_fee_bps : u8} , # [doc = " Whirlpool Swap Exact Output"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[signer]` token authority"] # [doc = " 3. `[writable]` whirlpool"] # [doc = " 4. `[writable]` token owner account a"] # [doc = " 5. `[writable]` token vault a"] # [doc = " 6. `[writable]` token owner account b"] # [doc = " 7. `[writable]` token vault b"] # [doc = " 8. `[writable]` tick array0"] # [doc = " 9. `[writable]` tick array1"] # [doc = " 10. `[writable]` tick array2"] # [doc = " 11. `[]` oracle"] WhirlpoolSwapExactOutput {out_amount : u64 , in_amount_with_slippage : AmountWithSlippage , a_to_b : bool , platform_fee_bps : u8} , # [doc = " Create Open Orders"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[writable]` open orders"] # [doc = " 1. `[signer, writable]` payer"] # [doc = " 2. `[]` dex program"] # [doc = " 3. `[]` system program"] # [doc = " 4. `[]` rent"] # [doc = " 5. `[]` market"] CreateOpenOrders , # [doc = " Mercurial Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` swap state"] # [doc = " 2. `[]` token program"] # [doc = " 3. `[]` pool authority"] # [doc = " 4. `[signer]` user transfer authority"] # [doc = " 5. `[writable]` source token account"] # [doc = " 6. `[writable]` destination token account"] MercurialSwap , # [doc = " Cykura Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[signer]` signer"] # [doc = " 2. `[]` factory state"] # [doc = " 3. `[writable]` pool state"] # [doc = " 4. `[writable]` input token account"] # [doc = " 5. `[writable]` output token account"] # [doc = " 6. `[writable]` input vault"] # [doc = " 7. `[writable]` output vault"] # [doc = " 8. `[writable]` last observation state"] # [doc = " 9. `[]` core program"] # [doc = " 10. `[]` token program"] CykuraSwap , # [doc = " Serum Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[writable]` market"] # [doc = " 1. `[writable]` open orders"] # [doc = " 2. `[writable]` request queue"] # [doc = " 3. `[writable]` event queue"] # [doc = " 4. `[writable]` bids"] # [doc = " 5. `[writable]` asks"] # [doc = " 6. `[writable]` coin vault"] # [doc = " 7. `[writable]` pc vault"] # [doc = " 8. `[]` vault signer"] # [doc = " 9. `[signer]` authority"] # [doc = " 10. `[writable]` order payer token account"] # [doc = " 11. `[writable]` coin wallet"] # [doc = " 12. `[writable]` pc wallet"] # [doc = " 13. `[]` dex program"] # [doc = " 14. `[]` token program"] # [doc = " 15. `[]` rent"] SerumSwap , # [doc = " Saber Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[]` swap"] # [doc = " 3. `[]` swap authority"] # [doc = " 4. `[]` user authority"] # [doc = " 5. `[writable]` input user account"] # [doc = " 6. `[writable]` input token account"] # [doc = " 7. `[writable]` output user account"] # [doc = " 8. `[writable]` output token account"] # [doc = " 9. `[writable]` fees token account"] SaberSwap , # [doc = " Saber Add Decimals"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` add decimals program"] # [doc = " 1. `[]` wrapper"] # [doc = " 2. `[writable]` wrapper mint"] # [doc = " 3. `[writable]` wrapper underlying tokens"] # [doc = " 4. `[signer]` owner"] # [doc = " 5. `[writable]` user underlying tokens"] # [doc = " 6. `[writable]` user wrapped tokens"] # [doc = " 7. `[]` token program"] SaberAddDecimals , # [doc = " Token Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` token swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[]` swap"] # [doc = " 3. `[]` authority"] # [doc = " 4. `[signer]` user transfer authority"] # [doc = " 5. `[writable]` source"] # [doc = " 6. `[writable]` swap source"] # [doc = " 7. `[writable]` swap destination"] # [doc = " 8. `[writable]` destination"] # [doc = " 9. `[writable]` pool mint"] # [doc = " 10. `[writable]` pool fee"] TokenSwap , # [doc = " Sencha Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[writable]` swap"] # [doc = " 3. `[]` user authority"] # [doc = " 4. `[writable]` input user account"] # [doc = " 5. `[writable]` input token account"] # [doc = " 6. `[writable]` input fees account"] # [doc = " 7. `[writable]` output user account"] # [doc = " 8. `[writable]` output token account"] # [doc = " 9. `[writable]` output fees account"] SenchaSwap , # [doc = " Step Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` token swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[]` swap"] # [doc = " 3. `[]` authority"] # [doc = " 4. `[signer]` user transfer authority"] # [doc = " 5. `[writable]` source"] # [doc = " 6. `[writable]` swap source"] # [doc = " 7. `[writable]` swap destination"] # [doc = " 8. `[writable]` destination"] # [doc = " 9. `[writable]` pool mint"] # [doc = " 10. `[writable]` pool fee"] StepSwap , # [doc = " Cropper Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` token swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[]` swap"] # [doc = " 3. `[]` swap state"] # [doc = " 4. `[]` authority"] # [doc = " 5. `[signer]` user transfer authority"] # [doc = " 6. `[writable]` source"] # [doc = " 7. `[writable]` swap source"] # [doc = " 8. `[writable]` swap destination"] # [doc = " 9. `[writable]` destination"] # [doc = " 10. `[writable]` pool mint"] # [doc = " 11. `[writable]` pool fee"] CropperSwap , # [doc = " Raydium Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[writable]` amm id"] # [doc = " 3. `[]` amm authority"] # [doc = " 4. `[writable]` amm open orders"] # [doc = " 5. `[writable]` pool coin token account"] # [doc = " 6. `[writable]` pool pc token account"] # [doc = " 7. `[]` serum program id"] # [doc = " 8. `[writable]` serum market"] # [doc = " 9. `[writable]` serum bids"] # [doc = " 10. `[writable]` serum asks"] # [doc = " 11. `[writable]` serum event queue"] # [doc = " 12. `[writable]` serum coin vault account"] # [doc = " 13. `[writable]` serum pc vault account"] # [doc = " 14. `[]` serum vault signer"] # [doc = " 15. `[writable]` user source token account"] # [doc = " 16. `[writable]` user destination token account"] # [doc = " 17. `[signer]` user source owner"] RaydiumSwap , # [doc = " Crema Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[writable]` pool"] # [doc = " 2. `[]` pool signer"] # [doc = " 3. `[writable]` user source token account"] # [doc = " 4. `[writable]` user destination token account"] # [doc = " 5. `[writable]` pool source token account"] # [doc = " 6. `[writable]` pool destination token account"] # [doc = " 7. `[writable]` pool ticks account"] # [doc = " 8. `[signer]` wallet authority"] # [doc = " 9. `[]` token program"] CremaSwap , # [doc = " Lifinity Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` authority"] # [doc = " 2. `[]` amm"] # [doc = " 3. `[signer]` user transfer authority"] # [doc = " 4. `[writable]` source info"] # [doc = " 5. `[writable]` destination info"] # [doc = " 6. `[writable]` swap source"] # [doc = " 7. `[writable]` swap destination"] # [doc = " 8. `[writable]` pool mint"] # [doc = " 9. `[writable]` fee account"] # [doc = " 10. `[]` token program"] # [doc = " 11. `[]` pyth account"] # [doc = " 12. `[]` pyth pc account"] # [doc = " 13. `[writable]` config account"] LifinitySwap , # [doc = " Marinade Deposit"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` marinade finance program"] # [doc = " 1. `[writable]` state"] # [doc = " 2. `[writable]` msol mint"] # [doc = " 3. `[writable]` liq pool sol leg pda"] # [doc = " 4. `[writable]` liq pool msol leg"] # [doc = " 5. `[]` liq pool msol leg authority"] # [doc = " 6. `[writable]` reserve pda"] # [doc = " 7. `[writable]` transfer from"] # [doc = " 8. `[writable]` mint to"] # [doc = " 9. `[]` msol mint authority"] # [doc = " 10. `[]` system program"] # [doc = " 11. `[]` token program"] # [doc = " 12. `[writable]` user wsol token account"] # [doc = " 13. `[writable]` temp wsol token account"] # [doc = " 14. `[signer, writable]` user transfer authority"] # [doc = " 15. `[]` wsol mint"] # [doc = " 16. `[]` rent"] MarinadeDeposit , # [doc = " Marinade Unstake"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` marinade finance program"] # [doc = " 1. `[writable]` state"] # [doc = " 2. `[writable]` msol mint"] # [doc = " 3. `[writable]` liq pool sol leg pda"] # [doc = " 4. `[writable]` liq pool msol leg"] # [doc = " 5. `[writable]` treasury msol account"] # [doc = " 6. `[writable]` get msol from"] # [doc = " 7. `[signer]` get msol from authority"] # [doc = " 8. `[writable]` transfer sol to"] # [doc = " 9. `[]` system program"] # [doc = " 10. `[]` token program"] # [doc = " 11. `[writable]` user wsol token account"] MarinadeUnstake , # [doc = " Aldrin Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` pool"] # [doc = " 2. `[]` pool signer"] # [doc = " 3. `[writable]` pool mint"] # [doc = " 4. `[writable]` base token vault"] # [doc = " 5. `[writable]` quote token vault"] # [doc = " 6. `[writable]` fee pool token account"] # [doc = " 7. `[signer]` wallet authority"] # [doc = " 8. `[writable]` user base token account"] # [doc = " 9. `[writable]` user quote token account"] # [doc = " 10. `[]` token program"] AldrinSwap , # [doc = " Aldrin V2 Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` pool"] # [doc = " 2. `[]` pool signer"] # [doc = " 3. `[writable]` pool mint"] # [doc = " 4. `[writable]` base token vault"] # [doc = " 5. `[writable]` quote token vault"] # [doc = " 6. `[writable]` fee pool token account"] # [doc = " 7. `[signer]` wallet authority"] # [doc = " 8. `[writable]` user base token account"] # [doc = " 9. `[writable]` user quote token account"] # [doc = " 10. `[]` curve"] # [doc = " 11. `[]` token program"] AldrinV2Swap , # [doc = " Whirlpool Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` token program"] # [doc = " 2. `[signer]` token authority"] # [doc = " 3. `[writable]` whirlpool"] # [doc = " 4. `[writable]` token owner account a"] # [doc = " 5. `[writable]` token vault a"] # [doc = " 6. `[writable]` token owner account b"] # [doc = " 7. `[writable]` token vault b"] # [doc = " 8. `[writable]` tick array0"] # [doc = " 9. `[writable]` tick array1"] # [doc = " 10. `[writable]` tick array2"] # [doc = " 11. `[]` oracle"] WhirlpoolSwap , # [doc = " Invariant Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` state"] # [doc = " 2. `[writable]` pool"] # [doc = " 3. `[writable]` tickmap"] # [doc = " 4. `[writable]` account x"] # [doc = " 5. `[writable]` account y"] # [doc = " 6. `[writable]` reserve x"] # [doc = " 7. `[writable]` reserve y"] # [doc = " 8. `[signer]` owner"] # [doc = " 9. `[]` program authority"] # [doc = " 10. `[]` token program"] InvariantSwap , # [doc = " Meteora Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[writable]` pool"] # [doc = " 2. `[writable]` user source token"] # [doc = " 3. `[writable]` user destination token"] # [doc = " 4. `[writable]` a vault"] # [doc = " 5. `[writable]` b vault"] # [doc = " 6. `[writable]` a token vault"] # [doc = " 7. `[writable]` b token vault"] # [doc = " 8. `[writable]` a vault lp mint"] # [doc = " 9. `[writable]` b vault lp mint"] # [doc = " 10. `[writable]` a vault lp"] # [doc = " 11. `[writable]` b vault lp"] # [doc = " 12. `[writable]` admin token fee"] # [doc = " 13. `[signer]` user"] # [doc = " 14. `[]` vault program"] # [doc = " 15. `[]` token program"] MeteoraSwap , # [doc = " Goosefx Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` controller"] # [doc = " 2. `[writable]` pair"] # [doc = " 3. `[writable]` ssl in"] # [doc = " 4. `[writable]` ssl out"] # [doc = " 5. `[writable]` liability vault in"] # [doc = " 6. `[writable]` swapped liability vault in"] # [doc = " 7. `[writable]` liability vault out"] # [doc = " 8. `[writable]` swapped liability vault out"] # [doc = " 9. `[writable]` user in ata"] # [doc = " 10. `[writable]` user out ata"] # [doc = " 11. `[writable]` fee collector ata"] # [doc = " 12. `[signer]` user wallet"] # [doc = " 13. `[]` fee collector"] # [doc = " 14. `[]` token program"] GoosefxSwap , # [doc = " Deltafi Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` market config"] # [doc = " 2. `[writable]` swap info"] # [doc = " 3. `[writable]` user source token"] # [doc = " 4. `[writable]` user destination token"] # [doc = " 5. `[writable]` swap source token"] # [doc = " 6. `[writable]` swap destination token"] # [doc = " 7. `[writable]` deltafi user"] # [doc = " 8. `[writable]` admin destination token"] # [doc = " 9. `[]` pyth price base"] # [doc = " 10. `[]` pyth price quote"] # [doc = " 11. `[signer]` user authority"] # [doc = " 12. `[]` token program"] DeltafiSwap , # [doc = " Balansol Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[signer, writable]` authority"] # [doc = " 2. `[writable]` pool"] # [doc = " 3. `[writable]` tax man"] # [doc = " 4. `[]` bid mint"] # [doc = " 5. `[]` treasurer"] # [doc = " 6. `[writable]` src treasury"] # [doc = " 7. `[writable]` src associated token account"] # [doc = " 8. `[]` ask mint"] # [doc = " 9. `[writable]` dst treasury"] # [doc = " 10. `[writable]` dst associated token account"] # [doc = " 11. `[writable]` dst token account taxman"] # [doc = " 12. `[]` system program"] # [doc = " 13. `[]` token program"] # [doc = " 14. `[]` associated token program"] # [doc = " 15. `[]` rent"] BalansolSwap , # [doc = " Marco Polo Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[]` state"] # [doc = " 2. `[writable]` pool"] # [doc = " 3. `[]` token x"] # [doc = " 4. `[]` token y"] # [doc = " 5. `[writable]` pool x account"] # [doc = " 6. `[writable]` pool y account"] # [doc = " 7. `[writable]` swapper x account"] # [doc = " 8. `[writable]` swapper y account"] # [doc = " 9. `[signer, writable]` swapper"] # [doc = " 10. `[writable]` referrer x account"] # [doc = " 11. `[writable]` referrer y account"] # [doc = " 12. `[writable]` referrer"] # [doc = " 13. `[]` program authority"] # [doc = " 14. `[]` system program"] # [doc = " 15. `[]` token program"] # [doc = " 16. `[]` associated token program"] # [doc = " 17. `[]` rent"] MarcoPoloSwap , # [doc = " Dradex Swap"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[]` swap program"] # [doc = " 1. `[writable]` pair"] # [doc = " 2. `[writable]` market"] # [doc = " 3. `[writable]` event queue"] # [doc = " 4. `[]` dex user"] # [doc = " 5. `[writable]` market user"] # [doc = " 6. `[writable]` bids"] # [doc = " 7. `[writable]` asks"] # [doc = " 8. `[writable]` t0 vault"] # [doc = " 9. `[writable]` t1 vault"] # [doc = " 10. `[writable]` t0 user"] # [doc = " 11. `[writable]` t1 user"] # [doc = " 12. `[]` master"] # [doc = " 13. `[signer, writable]` signer"] # [doc = " 14. `[]` system program"] # [doc = " 15. `[]` token program"] # [doc = " 16. `[]` logger"] DradexSwap} impl JupiterInstruction {pub fn sighash (& self) -> & 'static [u8 ; 8] {match self {Self :: Route {..} => & [229u8 , 23u8 , 203u8 , 151u8 , 122u8 , 227u8 , 173u8 , 42u8] , Self :: WhirlpoolSwapExactOutput {..} => & [39u8 , 58u8 , 38u8 , 128u8 , 100u8 , 62u8 , 191u8 , 249u8] , Self :: CreateOpenOrders => & [229u8 , 194u8 , 212u8 , 172u8 , 8u8 , 10u8 , 134u8 , 147u8] , Self :: MercurialSwap => & [2u8 , 5u8 , 77u8 , 173u8 , 197u8 , 0u8 , 7u8 , 157u8] , Self :: CykuraSwap => & [38u8 , 241u8 , 21u8 , 107u8 , 120u8 , 59u8 , 184u8 , 249u8] , Self :: SerumSwap => & [88u8 , 183u8 , 70u8 , 249u8 , 214u8 , 118u8 , 82u8 , 210u8] , Self :: SaberSwap => & [64u8 , 62u8 , 98u8 , 226u8 , 52u8 , 74u8 , 37u8 , 178u8] , Self :: SaberAddDecimals => & [36u8 , 53u8 , 231u8 , 184u8 , 7u8 , 181u8 , 5u8 , 238u8] , Self :: TokenSwap => & [187u8 , 192u8 , 118u8 , 212u8 , 62u8 , 109u8 , 28u8 , 213u8] , Self :: SenchaSwap => & [25u8 , 50u8 , 7u8 , 21u8 , 207u8 , 248u8 , 230u8 , 194u8] , Self :: StepSwap => & [155u8 , 56u8 , 208u8 , 198u8 , 27u8 , 61u8 , 149u8 , 233u8] , Self :: CropperSwap => & [230u8 , 216u8 , 47u8 , 182u8 , 165u8 , 117u8 , 210u8 , 103u8] , Self :: RaydiumSwap => & [177u8 , 173u8 , 42u8 , 240u8 , 184u8 , 4u8 , 124u8 , 81u8] , Self :: CremaSwap => & [169u8 , 220u8 , 41u8 , 250u8 , 35u8 , 190u8 , 133u8 , 198u8] , Self :: LifinitySwap => & [23u8 , 96u8 , 165u8 , 33u8 , 90u8 , 214u8 , 96u8 , 153u8] , Self :: MarinadeDeposit => & [62u8 , 236u8 , 248u8 , 28u8 , 222u8 , 232u8 , 182u8 , 73u8] , Self :: MarinadeUnstake => & [41u8 , 120u8 , 15u8 , 0u8 , 113u8 , 219u8 , 42u8 , 1u8] , Self :: AldrinSwap => & [251u8 , 232u8 , 119u8 , 166u8 , 225u8 , 185u8 , 169u8 , 161u8] , Self :: AldrinV2Swap => & [190u8 , 166u8 , 89u8 , 139u8 , 33u8 , 152u8 , 16u8 , 10u8] , Self :: WhirlpoolSwap => & [123u8 , 229u8 , 184u8 , 63u8 , 12u8 , 0u8 , 92u8 , 145u8] , Self :: InvariantSwap => & [187u8 , 193u8 , 40u8 , 121u8 , 47u8 , 73u8 , 144u8 , 177u8] , Self :: MeteoraSwap => & [127u8 , 125u8 , 226u8 , 12u8 , 81u8 , 24u8 , 204u8 , 35u8] , Self :: GoosefxSwap => & [222u8 , 136u8 , 46u8 , 123u8 , 189u8 , 125u8 , 124u8 , 122u8] , Self :: DeltafiSwap => & [132u8 , 230u8 , 102u8 , 120u8 , 205u8 , 9u8 , 237u8 , 190u8] , Self :: BalansolSwap => & [137u8 , 109u8 , 253u8 , 253u8 , 70u8 , 109u8 , 11u8 , 100u8] , Self :: MarcoPoloSwap => & [241u8 , 147u8 , 94u8 , 15u8 , 58u8 , 108u8 , 179u8 , 68u8] , Self :: DradexSwap => & [34u8 , 146u8 , 160u8 , 38u8 , 51u8 , 85u8 , 58u8 , 151u8]}} pub fn pack (self) -> Vec < u8 > {use :: borsh :: BorshSerialize ; let mut out = Vec :: new () ; out . extend (self . sighash ()) ; let data = self . try_to_vec () . unwrap () ; out . extend (data) ; out} pub fn unpack (data : & [u8]) -> :: std :: io :: Result < Self > {use :: borsh :: BorshDeserialize ; let (sighash , ix_data) = data . split_at (8) ; Ok (match sighash {[229u8 , 23u8 , 203u8 , 151u8 , 122u8 , 227u8 , 173u8 , 42u8] => {RouteDeserializer :: try_from_slice (ix_data) ? . into ()} [39u8 , 58u8 , 38u8 , 128u8 , 100u8 , 62u8 , 191u8 , 249u8] => {WhirlpoolSwapExactOutputDeserializer :: try_from_slice (ix_data) ? . into ()} [229u8 , 194u8 , 212u8 , 172u8 , 8u8 , 10u8 , 134u8 , 147u8] => {CreateOpenOrdersDeserializer :: try_from_slice (ix_data) ? . into ()} [2u8 , 5u8 , 77u8 , 173u8 , 197u8 , 0u8 , 7u8 , 157u8] => {MercurialSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [38u8 , 241u8 , 21u8 , 107u8 , 120u8 , 59u8 , 184u8 , 249u8] => {CykuraSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [88u8 , 183u8 , 70u8 , 249u8 , 214u8 , 118u8 , 82u8 , 210u8] => {SerumSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [64u8 , 62u8 , 98u8 , 226u8 , 52u8 , 74u8 , 37u8 , 178u8] => {SaberSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [36u8 , 53u8 , 231u8 , 184u8 , 7u8 , 181u8 , 5u8 , 238u8] => {SaberAddDecimalsDeserializer :: try_from_slice (ix_data) ? . into ()} [187u8 , 192u8 , 118u8 , 212u8 , 62u8 , 109u8 , 28u8 , 213u8] => {TokenSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [25u8 , 50u8 , 7u8 , 21u8 , 207u8 , 248u8 , 230u8 , 194u8] => {SenchaSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [155u8 , 56u8 , 208u8 , 198u8 , 27u8 , 61u8 , 149u8 , 233u8] => {StepSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [230u8 , 216u8 , 47u8 , 182u8 , 165u8 , 117u8 , 210u8 , 103u8] => {CropperSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [177u8 , 173u8 , 42u8 , 240u8 , 184u8 , 4u8 , 124u8 , 81u8] => {RaydiumSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [169u8 , 220u8 , 41u8 , 250u8 , 35u8 , 190u8 , 133u8 , 198u8] => {CremaSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [23u8 , 96u8 , 165u8 , 33u8 , 90u8 , 214u8 , 96u8 , 153u8] => {LifinitySwapDeserializer :: try_from_slice (ix_data) ? . into ()} [62u8 , 236u8 , 248u8 , 28u8 , 222u8 , 232u8 , 182u8 , 73u8] => {MarinadeDepositDeserializer :: try_from_slice (ix_data) ? . into ()} [41u8 , 120u8 , 15u8 , 0u8 , 113u8 , 219u8 , 42u8 , 1u8] => {MarinadeUnstakeDeserializer :: try_from_slice (ix_data) ? . into ()} [251u8 , 232u8 , 119u8 , 166u8 , 225u8 , 185u8 , 169u8 , 161u8] => {AldrinSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [190u8 , 166u8 , 89u8 , 139u8 , 33u8 , 152u8 , 16u8 , 10u8] => {AldrinV2SwapDeserializer :: try_from_slice (ix_data) ? . into ()} [123u8 , 229u8 , 184u8 , 63u8 , 12u8 , 0u8 , 92u8 , 145u8] => {WhirlpoolSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [187u8 , 193u8 , 40u8 , 121u8 , 47u8 , 73u8 , 144u8 , 177u8] => {InvariantSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [127u8 , 125u8 , 226u8 , 12u8 , 81u8 , 24u8 , 204u8 , 35u8] => {MeteoraSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [222u8 , 136u8 , 46u8 , 123u8 , 189u8 , 125u8 , 124u8 , 122u8] => {GoosefxSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [132u8 , 230u8 , 102u8 , 120u8 , 205u8 , 9u8 , 237u8 , 190u8] => {DeltafiSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [137u8 , 109u8 , 253u8 , 253u8 , 70u8 , 109u8 , 11u8 , 100u8] => {BalansolSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [241u8 , 147u8 , 94u8 , 15u8 , 58u8 , 108u8 , 179u8 , 68u8] => {MarcoPoloSwapDeserializer :: try_from_slice (ix_data) ? . into ()} [34u8 , 146u8 , 160u8 , 38u8 , 51u8 , 85u8 , 58u8 , 151u8] => {DradexSwapDeserializer :: try_from_slice (ix_data) ? . into ()} _ => return Err (std :: io :: Error :: new (std :: io :: ErrorKind :: InvalidInput , "invalid sighash" ,)) ,})}} impl :: borsh :: BorshSerialize for JupiterInstruction {fn serialize < W : :: borsh :: maybestd :: io :: Write > (& self , writer : & mut W ,) -> :: core :: result :: Result < () , :: borsh :: maybestd :: io :: Error > {match self {Self :: Route {swap_leg , in_amount , quoted_out_amount , slippage_bps , platform_fee_bps} => {:: borsh :: BorshSerialize :: serialize (swap_leg , writer) ? ; :: borsh :: BorshSerialize :: serialize (in_amount , writer) ? ; :: borsh :: BorshSerialize :: serialize (quoted_out_amount , writer) ? ; :: borsh :: BorshSerialize :: serialize (slippage_bps , writer) ? ; :: borsh :: BorshSerialize :: serialize (platform_fee_bps , writer) ? ;} Self :: WhirlpoolSwapExactOutput {out_amount , in_amount_with_slippage , a_to_b , platform_fee_bps} => {:: borsh :: BorshSerialize :: serialize (out_amount , writer) ? ; :: borsh :: BorshSerialize :: serialize (in_amount_with_slippage , writer) ? ; :: borsh :: BorshSerialize :: serialize (a_to_b , writer) ? ; :: borsh :: BorshSerialize :: serialize (platform_fee_bps , writer) ? ;} Self :: CreateOpenOrders => {} Self :: MercurialSwap => {} Self :: CykuraSwap => {} Self :: SerumSwap => {} Self :: SaberSwap => {} Self :: SaberAddDecimals => {} Self :: TokenSwap => {} Self :: SenchaSwap => {} Self :: StepSwap => {} Self :: CropperSwap => {} Self :: RaydiumSwap => {} Self :: CremaSwap => {} Self :: LifinitySwap => {} Self :: MarinadeDeposit => {} Self :: MarinadeUnstake => {} Self :: AldrinSwap => {} Self :: AldrinV2Swap => {} Self :: WhirlpoolSwap => {} Self :: InvariantSwap => {} Self :: MeteoraSwap => {} Self :: GoosefxSwap => {} Self :: DeltafiSwap => {} Self :: BalansolSwap => {} Self :: MarcoPoloSwap => {} Self :: DradexSwap => {}} Ok (())}} struct RouteDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for RouteDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: Route {swap_leg : :: borsh :: BorshDeserialize :: deserialize (buf) ? , in_amount : :: borsh :: BorshDeserialize :: deserialize (buf) ? , quoted_out_amount : :: borsh :: BorshDeserialize :: deserialize (buf) ? , slippage_bps : :: borsh :: BorshDeserialize :: deserialize (buf) ? , platform_fee_bps : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < RouteDeserializer > for JupiterInstruction {fn from (helper : RouteDeserializer) -> JupiterInstruction {helper . 0}} struct WhirlpoolSwapExactOutputDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for WhirlpoolSwapExactOutputDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: WhirlpoolSwapExactOutput {out_amount : :: borsh :: BorshDeserialize :: deserialize (buf) ? , in_amount_with_slippage : :: borsh :: BorshDeserialize :: deserialize (buf) ? , a_to_b : :: borsh :: BorshDeserialize :: deserialize (buf) ? , platform_fee_bps : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < WhirlpoolSwapExactOutputDeserializer > for JupiterInstruction {fn from (helper : WhirlpoolSwapExactOutputDeserializer) -> JupiterInstruction {helper . 0}} struct CreateOpenOrdersDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for CreateOpenOrdersDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: CreateOpenOrders {}))}} impl From < CreateOpenOrdersDeserializer > for JupiterInstruction {fn from (helper : CreateOpenOrdersDeserializer) -> JupiterInstruction {helper . 0}} struct MercurialSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for MercurialSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: MercurialSwap {}))}} impl From < MercurialSwapDeserializer > for JupiterInstruction {fn from (helper : MercurialSwapDeserializer) -> JupiterInstruction {helper . 0}} struct CykuraSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for CykuraSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: CykuraSwap {}))}} impl From < CykuraSwapDeserializer > for JupiterInstruction {fn from (helper : CykuraSwapDeserializer) -> JupiterInstruction {helper . 0}} struct SerumSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for SerumSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: SerumSwap {}))}} impl From < SerumSwapDeserializer > for JupiterInstruction {fn from (helper : SerumSwapDeserializer) -> JupiterInstruction {helper . 0}} struct SaberSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for SaberSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: SaberSwap {}))}} impl From < SaberSwapDeserializer > for JupiterInstruction {fn from (helper : SaberSwapDeserializer) -> JupiterInstruction {helper . 0}} struct SaberAddDecimalsDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for SaberAddDecimalsDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: SaberAddDecimals {}))}} impl From < SaberAddDecimalsDeserializer > for JupiterInstruction {fn from (helper : SaberAddDecimalsDeserializer) -> JupiterInstruction {helper . 0}} struct TokenSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for TokenSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: TokenSwap {}))}} impl From < TokenSwapDeserializer > for JupiterInstruction {fn from (helper : TokenSwapDeserializer) -> JupiterInstruction {helper . 0}} struct SenchaSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for SenchaSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: SenchaSwap {}))}} impl From < SenchaSwapDeserializer > for JupiterInstruction {fn from (helper : SenchaSwapDeserializer) -> JupiterInstruction {helper . 0}} struct StepSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for StepSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: StepSwap {}))}} impl From < StepSwapDeserializer > for JupiterInstruction {fn from (helper : StepSwapDeserializer) -> JupiterInstruction {helper . 0}} struct CropperSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for CropperSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: CropperSwap {}))}} impl From < CropperSwapDeserializer > for JupiterInstruction {fn from (helper : CropperSwapDeserializer) -> JupiterInstruction {helper . 0}} struct RaydiumSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for RaydiumSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: RaydiumSwap {}))}} impl From < RaydiumSwapDeserializer > for JupiterInstruction {fn from (helper : RaydiumSwapDeserializer) -> JupiterInstruction {helper . 0}} struct CremaSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for CremaSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: CremaSwap {}))}} impl From < CremaSwapDeserializer > for JupiterInstruction {fn from (helper : CremaSwapDeserializer) -> JupiterInstruction {helper . 0}} struct LifinitySwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for LifinitySwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: LifinitySwap {}))}} impl From < LifinitySwapDeserializer > for JupiterInstruction {fn from (helper : LifinitySwapDeserializer) -> JupiterInstruction {helper . 0}} struct MarinadeDepositDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for MarinadeDepositDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: MarinadeDeposit {}))}} impl From < MarinadeDepositDeserializer > for JupiterInstruction {fn from (helper : MarinadeDepositDeserializer) -> JupiterInstruction {helper . 0}} struct MarinadeUnstakeDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for MarinadeUnstakeDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: MarinadeUnstake {}))}} impl From < MarinadeUnstakeDeserializer > for JupiterInstruction {fn from (helper : MarinadeUnstakeDeserializer) -> JupiterInstruction {helper . 0}} struct AldrinSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for AldrinSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: AldrinSwap {}))}} impl From < AldrinSwapDeserializer > for JupiterInstruction {fn from (helper : AldrinSwapDeserializer) -> JupiterInstruction {helper . 0}} struct AldrinV2SwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for AldrinV2SwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: AldrinV2Swap {}))}} impl From < AldrinV2SwapDeserializer > for JupiterInstruction {fn from (helper : AldrinV2SwapDeserializer) -> JupiterInstruction {helper . 0}} struct WhirlpoolSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for WhirlpoolSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: WhirlpoolSwap {}))}} impl From < WhirlpoolSwapDeserializer > for JupiterInstruction {fn from (helper : WhirlpoolSwapDeserializer) -> JupiterInstruction {helper . 0}} struct InvariantSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for InvariantSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: InvariantSwap {}))}} impl From < InvariantSwapDeserializer > for JupiterInstruction {fn from (helper : InvariantSwapDeserializer) -> JupiterInstruction {helper . 0}} struct MeteoraSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for MeteoraSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: MeteoraSwap {}))}} impl From < MeteoraSwapDeserializer > for JupiterInstruction {fn from (helper : MeteoraSwapDeserializer) -> JupiterInstruction {helper . 0}} struct GoosefxSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for GoosefxSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: GoosefxSwap {}))}} impl From < GoosefxSwapDeserializer > for JupiterInstruction {fn from (helper : GoosefxSwapDeserializer) -> JupiterInstruction {helper . 0}} struct DeltafiSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for DeltafiSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: DeltafiSwap {}))}} impl From < DeltafiSwapDeserializer > for JupiterInstruction {fn from (helper : DeltafiSwapDeserializer) -> JupiterInstruction {helper . 0}} struct BalansolSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for BalansolSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: BalansolSwap {}))}} impl From < BalansolSwapDeserializer > for JupiterInstruction {fn from (helper : BalansolSwapDeserializer) -> JupiterInstruction {helper . 0}} struct MarcoPoloSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for MarcoPoloSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: MarcoPoloSwap {}))}} impl From < MarcoPoloSwapDeserializer > for JupiterInstruction {fn from (helper : MarcoPoloSwapDeserializer) -> JupiterInstruction {helper . 0}} struct DradexSwapDeserializer (JupiterInstruction) ; impl :: borsh :: de :: BorshDeserialize for DradexSwapDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (JupiterInstruction :: DradexSwap {}))}} impl From < DradexSwapDeserializer > for JupiterInstruction {fn from (helper : DradexSwapDeserializer) -> JupiterInstruction {helper . 0}} # [derive (Debug)] pub struct Route {pub program_id : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub destination_token_account : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub swap_leg : SwapLeg , pub in_amount : u64 , pub quoted_out_amount : u64 , pub slippage_bps : u16 , pub platform_fee_bps : u8 ,} impl Route {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , token_program , user_transfer_authority , destination_token_account , trailing_accounts , swap_leg , in_amount , quoted_out_amount , slippage_bps , platform_fee_bps ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (user_transfer_authority , true) , AccountMeta :: new_readonly (destination_token_account , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: Route {swap_leg , in_amount , quoted_out_amount , slippage_bps , platform_fee_bps ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct WhirlpoolSwapExactOutput {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub token_authority : :: solana_program :: pubkey :: Pubkey , pub whirlpool : :: solana_program :: pubkey :: Pubkey , pub token_owner_account_a : :: solana_program :: pubkey :: Pubkey , pub token_vault_a : :: solana_program :: pubkey :: Pubkey , pub token_owner_account_b : :: solana_program :: pubkey :: Pubkey , pub token_vault_b : :: solana_program :: pubkey :: Pubkey , pub tick_array0 : :: solana_program :: pubkey :: Pubkey , pub tick_array1 : :: solana_program :: pubkey :: Pubkey , pub tick_array2 : :: solana_program :: pubkey :: Pubkey , pub oracle : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub out_amount : u64 , pub in_amount_with_slippage : AmountWithSlippage , pub a_to_b : bool , pub platform_fee_bps : u8 ,} impl WhirlpoolSwapExactOutput {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , token_program , token_authority , whirlpool , token_owner_account_a , token_vault_a , token_owner_account_b , token_vault_b , tick_array0 , tick_array1 , tick_array2 , oracle , trailing_accounts , out_amount , in_amount_with_slippage , a_to_b , platform_fee_bps ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (token_authority , true) , AccountMeta :: new (whirlpool , false) , AccountMeta :: new (token_owner_account_a , false) , AccountMeta :: new (token_vault_a , false) , AccountMeta :: new (token_owner_account_b , false) , AccountMeta :: new (token_vault_b , false) , AccountMeta :: new (tick_array0 , false) , AccountMeta :: new (tick_array1 , false) , AccountMeta :: new (tick_array2 , false) , AccountMeta :: new_readonly (oracle , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: WhirlpoolSwapExactOutput {out_amount , in_amount_with_slippage , a_to_b , platform_fee_bps ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct CreateOpenOrders {pub program_id : :: solana_program :: pubkey :: Pubkey , pub open_orders : :: solana_program :: pubkey :: Pubkey , pub payer : :: solana_program :: pubkey :: Pubkey , pub dex_program : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub market : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl CreateOpenOrders {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , open_orders , payer , dex_program , system_program , rent , market , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new (open_orders , false) , AccountMeta :: new (payer , true) , AccountMeta :: new_readonly (dex_program , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (rent , false) , AccountMeta :: new_readonly (market , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: CreateOpenOrders {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MercurialSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub swap_state : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub pool_authority : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub source_token_account : :: solana_program :: pubkey :: Pubkey , pub destination_token_account : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl MercurialSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , swap_state , token_program , pool_authority , user_transfer_authority , source_token_account , destination_token_account , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (swap_state , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (pool_authority , false) , AccountMeta :: new_readonly (user_transfer_authority , true) , AccountMeta :: new (source_token_account , false) , AccountMeta :: new (destination_token_account , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: MercurialSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct CykuraSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub signer : :: solana_program :: pubkey :: Pubkey , pub factory_state : :: solana_program :: pubkey :: Pubkey , pub pool_state : :: solana_program :: pubkey :: Pubkey , pub input_token_account : :: solana_program :: pubkey :: Pubkey , pub output_token_account : :: solana_program :: pubkey :: Pubkey , pub input_vault : :: solana_program :: pubkey :: Pubkey , pub output_vault : :: solana_program :: pubkey :: Pubkey , pub last_observation_state : :: solana_program :: pubkey :: Pubkey , pub core_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl CykuraSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , signer , factory_state , pool_state , input_token_account , output_token_account , input_vault , output_vault , last_observation_state , core_program , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (signer , true) , AccountMeta :: new_readonly (factory_state , false) , AccountMeta :: new (pool_state , false) , AccountMeta :: new (input_token_account , false) , AccountMeta :: new (output_token_account , false) , AccountMeta :: new (input_vault , false) , AccountMeta :: new (output_vault , false) , AccountMeta :: new (last_observation_state , false) , AccountMeta :: new_readonly (core_program , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: CykuraSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct SerumSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub market : :: solana_program :: pubkey :: Pubkey , pub open_orders : :: solana_program :: pubkey :: Pubkey , pub request_queue : :: solana_program :: pubkey :: Pubkey , pub event_queue : :: solana_program :: pubkey :: Pubkey , pub bids : :: solana_program :: pubkey :: Pubkey , pub asks : :: solana_program :: pubkey :: Pubkey , pub coin_vault : :: solana_program :: pubkey :: Pubkey , pub pc_vault : :: solana_program :: pubkey :: Pubkey , pub vault_signer : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub order_payer_token_account : :: solana_program :: pubkey :: Pubkey , pub coin_wallet : :: solana_program :: pubkey :: Pubkey , pub pc_wallet : :: solana_program :: pubkey :: Pubkey , pub dex_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl SerumSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , market , open_orders , request_queue , event_queue , bids , asks , coin_vault , pc_vault , vault_signer , authority , order_payer_token_account , coin_wallet , pc_wallet , dex_program , token_program , rent , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new (market , false) , AccountMeta :: new (open_orders , false) , AccountMeta :: new (request_queue , false) , AccountMeta :: new (event_queue , false) , AccountMeta :: new (bids , false) , AccountMeta :: new (asks , false) , AccountMeta :: new (coin_vault , false) , AccountMeta :: new (pc_vault , false) , AccountMeta :: new_readonly (vault_signer , false) , AccountMeta :: new_readonly (authority , true) , AccountMeta :: new (order_payer_token_account , false) , AccountMeta :: new (coin_wallet , false) , AccountMeta :: new (pc_wallet , false) , AccountMeta :: new_readonly (dex_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (rent , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: SerumSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct SaberSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub swap : :: solana_program :: pubkey :: Pubkey , pub swap_authority : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub input_user_account : :: solana_program :: pubkey :: Pubkey , pub input_token_account : :: solana_program :: pubkey :: Pubkey , pub output_user_account : :: solana_program :: pubkey :: Pubkey , pub output_token_account : :: solana_program :: pubkey :: Pubkey , pub fees_token_account : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl SaberSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , token_program , swap , swap_authority , user_authority , input_user_account , input_token_account , output_user_account , output_token_account , fees_token_account , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (swap , false) , AccountMeta :: new_readonly (swap_authority , false) , AccountMeta :: new_readonly (user_authority , false) , AccountMeta :: new (input_user_account , false) , AccountMeta :: new (input_token_account , false) , AccountMeta :: new (output_user_account , false) , AccountMeta :: new (output_token_account , false) , AccountMeta :: new (fees_token_account , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: SaberSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct SaberAddDecimals {pub program_id : :: solana_program :: pubkey :: Pubkey , pub add_decimals_program : :: solana_program :: pubkey :: Pubkey , pub wrapper : :: solana_program :: pubkey :: Pubkey , pub wrapper_mint : :: solana_program :: pubkey :: Pubkey , pub wrapper_underlying_tokens : :: solana_program :: pubkey :: Pubkey , pub owner : :: solana_program :: pubkey :: Pubkey , pub user_underlying_tokens : :: solana_program :: pubkey :: Pubkey , pub user_wrapped_tokens : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl SaberAddDecimals {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , add_decimals_program , wrapper , wrapper_mint , wrapper_underlying_tokens , owner , user_underlying_tokens , user_wrapped_tokens , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (add_decimals_program , false) , AccountMeta :: new_readonly (wrapper , false) , AccountMeta :: new (wrapper_mint , false) , AccountMeta :: new (wrapper_underlying_tokens , false) , AccountMeta :: new_readonly (owner , true) , AccountMeta :: new (user_underlying_tokens , false) , AccountMeta :: new (user_wrapped_tokens , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: SaberAddDecimals {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct TokenSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub token_swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub swap : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub source : :: solana_program :: pubkey :: Pubkey , pub swap_source : :: solana_program :: pubkey :: Pubkey , pub swap_destination : :: solana_program :: pubkey :: Pubkey , pub destination : :: solana_program :: pubkey :: Pubkey , pub pool_mint : :: solana_program :: pubkey :: Pubkey , pub pool_fee : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl TokenSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , token_swap_program , token_program , swap , authority , user_transfer_authority , source , swap_source , swap_destination , destination , pool_mint , pool_fee , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (token_swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (swap , false) , AccountMeta :: new_readonly (authority , false) , AccountMeta :: new_readonly (user_transfer_authority , true) , AccountMeta :: new (source , false) , AccountMeta :: new (swap_source , false) , AccountMeta :: new (swap_destination , false) , AccountMeta :: new (destination , false) , AccountMeta :: new (pool_mint , false) , AccountMeta :: new (pool_fee , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: TokenSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct SenchaSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub swap : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub input_user_account : :: solana_program :: pubkey :: Pubkey , pub input_token_account : :: solana_program :: pubkey :: Pubkey , pub input_fees_account : :: solana_program :: pubkey :: Pubkey , pub output_user_account : :: solana_program :: pubkey :: Pubkey , pub output_token_account : :: solana_program :: pubkey :: Pubkey , pub output_fees_account : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl SenchaSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , token_program , swap , user_authority , input_user_account , input_token_account , input_fees_account , output_user_account , output_token_account , output_fees_account , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new (swap , false) , AccountMeta :: new_readonly (user_authority , false) , AccountMeta :: new (input_user_account , false) , AccountMeta :: new (input_token_account , false) , AccountMeta :: new (input_fees_account , false) , AccountMeta :: new (output_user_account , false) , AccountMeta :: new (output_token_account , false) , AccountMeta :: new (output_fees_account , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: SenchaSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct StepSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub token_swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub swap : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub source : :: solana_program :: pubkey :: Pubkey , pub swap_source : :: solana_program :: pubkey :: Pubkey , pub swap_destination : :: solana_program :: pubkey :: Pubkey , pub destination : :: solana_program :: pubkey :: Pubkey , pub pool_mint : :: solana_program :: pubkey :: Pubkey , pub pool_fee : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl StepSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , token_swap_program , token_program , swap , authority , user_transfer_authority , source , swap_source , swap_destination , destination , pool_mint , pool_fee , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (token_swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (swap , false) , AccountMeta :: new_readonly (authority , false) , AccountMeta :: new_readonly (user_transfer_authority , true) , AccountMeta :: new (source , false) , AccountMeta :: new (swap_source , false) , AccountMeta :: new (swap_destination , false) , AccountMeta :: new (destination , false) , AccountMeta :: new (pool_mint , false) , AccountMeta :: new (pool_fee , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: StepSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct CropperSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub token_swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub swap : :: solana_program :: pubkey :: Pubkey , pub swap_state : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub source : :: solana_program :: pubkey :: Pubkey , pub swap_source : :: solana_program :: pubkey :: Pubkey , pub swap_destination : :: solana_program :: pubkey :: Pubkey , pub destination : :: solana_program :: pubkey :: Pubkey , pub pool_mint : :: solana_program :: pubkey :: Pubkey , pub pool_fee : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl CropperSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , token_swap_program , token_program , swap , swap_state , authority , user_transfer_authority , source , swap_source , swap_destination , destination , pool_mint , pool_fee , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (token_swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (swap , false) , AccountMeta :: new_readonly (swap_state , false) , AccountMeta :: new_readonly (authority , false) , AccountMeta :: new_readonly (user_transfer_authority , true) , AccountMeta :: new (source , false) , AccountMeta :: new (swap_source , false) , AccountMeta :: new (swap_destination , false) , AccountMeta :: new (destination , false) , AccountMeta :: new (pool_mint , false) , AccountMeta :: new (pool_fee , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: CropperSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct RaydiumSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub amm_id : :: solana_program :: pubkey :: Pubkey , pub amm_authority : :: solana_program :: pubkey :: Pubkey , pub amm_open_orders : :: solana_program :: pubkey :: Pubkey , pub pool_coin_token_account : :: solana_program :: pubkey :: Pubkey , pub pool_pc_token_account : :: solana_program :: pubkey :: Pubkey , pub serum_program_id : :: solana_program :: pubkey :: Pubkey , pub serum_market : :: solana_program :: pubkey :: Pubkey , pub serum_bids : :: solana_program :: pubkey :: Pubkey , pub serum_asks : :: solana_program :: pubkey :: Pubkey , pub serum_event_queue : :: solana_program :: pubkey :: Pubkey , pub serum_coin_vault_account : :: solana_program :: pubkey :: Pubkey , pub serum_pc_vault_account : :: solana_program :: pubkey :: Pubkey , pub serum_vault_signer : :: solana_program :: pubkey :: Pubkey , pub user_source_token_account : :: solana_program :: pubkey :: Pubkey , pub user_destination_token_account : :: solana_program :: pubkey :: Pubkey , pub user_source_owner : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl RaydiumSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , token_program , amm_id , amm_authority , amm_open_orders , pool_coin_token_account , pool_pc_token_account , serum_program_id , serum_market , serum_bids , serum_asks , serum_event_queue , serum_coin_vault_account , serum_pc_vault_account , serum_vault_signer , user_source_token_account , user_destination_token_account , user_source_owner , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new (amm_id , false) , AccountMeta :: new_readonly (amm_authority , false) , AccountMeta :: new (amm_open_orders , false) , AccountMeta :: new (pool_coin_token_account , false) , AccountMeta :: new (pool_pc_token_account , false) , AccountMeta :: new_readonly (serum_program_id , false) , AccountMeta :: new (serum_market , false) , AccountMeta :: new (serum_bids , false) , AccountMeta :: new (serum_asks , false) , AccountMeta :: new (serum_event_queue , false) , AccountMeta :: new (serum_coin_vault_account , false) , AccountMeta :: new (serum_pc_vault_account , false) , AccountMeta :: new_readonly (serum_vault_signer , false) , AccountMeta :: new (user_source_token_account , false) , AccountMeta :: new (user_destination_token_account , false) , AccountMeta :: new_readonly (user_source_owner , true) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: RaydiumSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct CremaSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub pool_signer : :: solana_program :: pubkey :: Pubkey , pub user_source_token_account : :: solana_program :: pubkey :: Pubkey , pub user_destination_token_account : :: solana_program :: pubkey :: Pubkey , pub pool_source_token_account : :: solana_program :: pubkey :: Pubkey , pub pool_destination_token_account : :: solana_program :: pubkey :: Pubkey , pub pool_ticks_account : :: solana_program :: pubkey :: Pubkey , pub wallet_authority : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl CremaSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , pool , pool_signer , user_source_token_account , user_destination_token_account , pool_source_token_account , pool_destination_token_account , pool_ticks_account , wallet_authority , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new (pool , false) , AccountMeta :: new_readonly (pool_signer , false) , AccountMeta :: new (user_source_token_account , false) , AccountMeta :: new (user_destination_token_account , false) , AccountMeta :: new (pool_source_token_account , false) , AccountMeta :: new (pool_destination_token_account , false) , AccountMeta :: new (pool_ticks_account , false) , AccountMeta :: new_readonly (wallet_authority , true) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: CremaSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct LifinitySwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub amm : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub source_info : :: solana_program :: pubkey :: Pubkey , pub destination_info : :: solana_program :: pubkey :: Pubkey , pub swap_source : :: solana_program :: pubkey :: Pubkey , pub swap_destination : :: solana_program :: pubkey :: Pubkey , pub pool_mint : :: solana_program :: pubkey :: Pubkey , pub fee_account : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub pyth_account : :: solana_program :: pubkey :: Pubkey , pub pyth_pc_account : :: solana_program :: pubkey :: Pubkey , pub config_account : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl LifinitySwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , authority , amm , user_transfer_authority , source_info , destination_info , swap_source , swap_destination , pool_mint , fee_account , token_program , pyth_account , pyth_pc_account , config_account , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (authority , false) , AccountMeta :: new_readonly (amm , false) , AccountMeta :: new_readonly (user_transfer_authority , true) , AccountMeta :: new (source_info , false) , AccountMeta :: new (destination_info , false) , AccountMeta :: new (swap_source , false) , AccountMeta :: new (swap_destination , false) , AccountMeta :: new (pool_mint , false) , AccountMeta :: new (fee_account , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (pyth_account , false) , AccountMeta :: new_readonly (pyth_pc_account , false) , AccountMeta :: new (config_account , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: LifinitySwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MarinadeDeposit {pub program_id : :: solana_program :: pubkey :: Pubkey , pub marinade_finance_program : :: solana_program :: pubkey :: Pubkey , pub state : :: solana_program :: pubkey :: Pubkey , pub msol_mint : :: solana_program :: pubkey :: Pubkey , pub liq_pool_sol_leg_pda : :: solana_program :: pubkey :: Pubkey , pub liq_pool_msol_leg : :: solana_program :: pubkey :: Pubkey , pub liq_pool_msol_leg_authority : :: solana_program :: pubkey :: Pubkey , pub reserve_pda : :: solana_program :: pubkey :: Pubkey , pub transfer_from : :: solana_program :: pubkey :: Pubkey , pub mint_to : :: solana_program :: pubkey :: Pubkey , pub msol_mint_authority : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub user_wsol_token_account : :: solana_program :: pubkey :: Pubkey , pub temp_wsol_token_account : :: solana_program :: pubkey :: Pubkey , pub user_transfer_authority : :: solana_program :: pubkey :: Pubkey , pub wsol_mint : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl MarinadeDeposit {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , marinade_finance_program , state , msol_mint , liq_pool_sol_leg_pda , liq_pool_msol_leg , liq_pool_msol_leg_authority , reserve_pda , transfer_from , mint_to , msol_mint_authority , system_program , token_program , user_wsol_token_account , temp_wsol_token_account , user_transfer_authority , wsol_mint , rent , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (marinade_finance_program , false) , AccountMeta :: new (state , false) , AccountMeta :: new (msol_mint , false) , AccountMeta :: new (liq_pool_sol_leg_pda , false) , AccountMeta :: new (liq_pool_msol_leg , false) , AccountMeta :: new_readonly (liq_pool_msol_leg_authority , false) , AccountMeta :: new (reserve_pda , false) , AccountMeta :: new (transfer_from , false) , AccountMeta :: new (mint_to , false) , AccountMeta :: new_readonly (msol_mint_authority , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new (user_wsol_token_account , false) , AccountMeta :: new (temp_wsol_token_account , false) , AccountMeta :: new (user_transfer_authority , true) , AccountMeta :: new_readonly (wsol_mint , false) , AccountMeta :: new_readonly (rent , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: MarinadeDeposit {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MarinadeUnstake {pub program_id : :: solana_program :: pubkey :: Pubkey , pub marinade_finance_program : :: solana_program :: pubkey :: Pubkey , pub state : :: solana_program :: pubkey :: Pubkey , pub msol_mint : :: solana_program :: pubkey :: Pubkey , pub liq_pool_sol_leg_pda : :: solana_program :: pubkey :: Pubkey , pub liq_pool_msol_leg : :: solana_program :: pubkey :: Pubkey , pub treasury_msol_account : :: solana_program :: pubkey :: Pubkey , pub get_msol_from : :: solana_program :: pubkey :: Pubkey , pub get_msol_from_authority : :: solana_program :: pubkey :: Pubkey , pub transfer_sol_to : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub user_wsol_token_account : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl MarinadeUnstake {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , marinade_finance_program , state , msol_mint , liq_pool_sol_leg_pda , liq_pool_msol_leg , treasury_msol_account , get_msol_from , get_msol_from_authority , transfer_sol_to , system_program , token_program , user_wsol_token_account , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (marinade_finance_program , false) , AccountMeta :: new (state , false) , AccountMeta :: new (msol_mint , false) , AccountMeta :: new (liq_pool_sol_leg_pda , false) , AccountMeta :: new (liq_pool_msol_leg , false) , AccountMeta :: new (treasury_msol_account , false) , AccountMeta :: new (get_msol_from , false) , AccountMeta :: new_readonly (get_msol_from_authority , true) , AccountMeta :: new (transfer_sol_to , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new (user_wsol_token_account , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: MarinadeUnstake {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct AldrinSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub pool_signer : :: solana_program :: pubkey :: Pubkey , pub pool_mint : :: solana_program :: pubkey :: Pubkey , pub base_token_vault : :: solana_program :: pubkey :: Pubkey , pub quote_token_vault : :: solana_program :: pubkey :: Pubkey , pub fee_pool_token_account : :: solana_program :: pubkey :: Pubkey , pub wallet_authority : :: solana_program :: pubkey :: Pubkey , pub user_base_token_account : :: solana_program :: pubkey :: Pubkey , pub user_quote_token_account : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl AldrinSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , pool , pool_signer , pool_mint , base_token_vault , quote_token_vault , fee_pool_token_account , wallet_authority , user_base_token_account , user_quote_token_account , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (pool , false) , AccountMeta :: new_readonly (pool_signer , false) , AccountMeta :: new (pool_mint , false) , AccountMeta :: new (base_token_vault , false) , AccountMeta :: new (quote_token_vault , false) , AccountMeta :: new (fee_pool_token_account , false) , AccountMeta :: new_readonly (wallet_authority , true) , AccountMeta :: new (user_base_token_account , false) , AccountMeta :: new (user_quote_token_account , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: AldrinSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct AldrinV2Swap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub pool_signer : :: solana_program :: pubkey :: Pubkey , pub pool_mint : :: solana_program :: pubkey :: Pubkey , pub base_token_vault : :: solana_program :: pubkey :: Pubkey , pub quote_token_vault : :: solana_program :: pubkey :: Pubkey , pub fee_pool_token_account : :: solana_program :: pubkey :: Pubkey , pub wallet_authority : :: solana_program :: pubkey :: Pubkey , pub user_base_token_account : :: solana_program :: pubkey :: Pubkey , pub user_quote_token_account : :: solana_program :: pubkey :: Pubkey , pub curve : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl AldrinV2Swap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , pool , pool_signer , pool_mint , base_token_vault , quote_token_vault , fee_pool_token_account , wallet_authority , user_base_token_account , user_quote_token_account , curve , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (pool , false) , AccountMeta :: new_readonly (pool_signer , false) , AccountMeta :: new (pool_mint , false) , AccountMeta :: new (base_token_vault , false) , AccountMeta :: new (quote_token_vault , false) , AccountMeta :: new (fee_pool_token_account , false) , AccountMeta :: new_readonly (wallet_authority , true) , AccountMeta :: new (user_base_token_account , false) , AccountMeta :: new (user_quote_token_account , false) , AccountMeta :: new_readonly (curve , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: AldrinV2Swap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct WhirlpoolSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub token_authority : :: solana_program :: pubkey :: Pubkey , pub whirlpool : :: solana_program :: pubkey :: Pubkey , pub token_owner_account_a : :: solana_program :: pubkey :: Pubkey , pub token_vault_a : :: solana_program :: pubkey :: Pubkey , pub token_owner_account_b : :: solana_program :: pubkey :: Pubkey , pub token_vault_b : :: solana_program :: pubkey :: Pubkey , pub tick_array0 : :: solana_program :: pubkey :: Pubkey , pub tick_array1 : :: solana_program :: pubkey :: Pubkey , pub tick_array2 : :: solana_program :: pubkey :: Pubkey , pub oracle : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl WhirlpoolSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , token_program , token_authority , whirlpool , token_owner_account_a , token_vault_a , token_owner_account_b , token_vault_b , tick_array0 , tick_array1 , tick_array2 , oracle , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (token_authority , true) , AccountMeta :: new (whirlpool , false) , AccountMeta :: new (token_owner_account_a , false) , AccountMeta :: new (token_vault_a , false) , AccountMeta :: new (token_owner_account_b , false) , AccountMeta :: new (token_vault_b , false) , AccountMeta :: new (tick_array0 , false) , AccountMeta :: new (tick_array1 , false) , AccountMeta :: new (tick_array2 , false) , AccountMeta :: new_readonly (oracle , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: WhirlpoolSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct InvariantSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub state : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub tickmap : :: solana_program :: pubkey :: Pubkey , pub account_x : :: solana_program :: pubkey :: Pubkey , pub account_y : :: solana_program :: pubkey :: Pubkey , pub reserve_x : :: solana_program :: pubkey :: Pubkey , pub reserve_y : :: solana_program :: pubkey :: Pubkey , pub owner : :: solana_program :: pubkey :: Pubkey , pub program_authority : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl InvariantSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , state , pool , tickmap , account_x , account_y , reserve_x , reserve_y , owner , program_authority , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (state , false) , AccountMeta :: new (pool , false) , AccountMeta :: new (tickmap , false) , AccountMeta :: new (account_x , false) , AccountMeta :: new (account_y , false) , AccountMeta :: new (reserve_x , false) , AccountMeta :: new (reserve_y , false) , AccountMeta :: new_readonly (owner , true) , AccountMeta :: new_readonly (program_authority , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: InvariantSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MeteoraSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub user_source_token : :: solana_program :: pubkey :: Pubkey , pub user_destination_token : :: solana_program :: pubkey :: Pubkey , pub a_vault : :: solana_program :: pubkey :: Pubkey , pub b_vault : :: solana_program :: pubkey :: Pubkey , pub a_token_vault : :: solana_program :: pubkey :: Pubkey , pub b_token_vault : :: solana_program :: pubkey :: Pubkey , pub a_vault_lp_mint : :: solana_program :: pubkey :: Pubkey , pub b_vault_lp_mint : :: solana_program :: pubkey :: Pubkey , pub a_vault_lp : :: solana_program :: pubkey :: Pubkey , pub b_vault_lp : :: solana_program :: pubkey :: Pubkey , pub admin_token_fee : :: solana_program :: pubkey :: Pubkey , pub user : :: solana_program :: pubkey :: Pubkey , pub vault_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl MeteoraSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , pool , user_source_token , user_destination_token , a_vault , b_vault , a_token_vault , b_token_vault , a_vault_lp_mint , b_vault_lp_mint , a_vault_lp , b_vault_lp , admin_token_fee , user , vault_program , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new (pool , false) , AccountMeta :: new (user_source_token , false) , AccountMeta :: new (user_destination_token , false) , AccountMeta :: new (a_vault , false) , AccountMeta :: new (b_vault , false) , AccountMeta :: new (a_token_vault , false) , AccountMeta :: new (b_token_vault , false) , AccountMeta :: new (a_vault_lp_mint , false) , AccountMeta :: new (b_vault_lp_mint , false) , AccountMeta :: new (a_vault_lp , false) , AccountMeta :: new (b_vault_lp , false) , AccountMeta :: new (admin_token_fee , false) , AccountMeta :: new_readonly (user , true) , AccountMeta :: new_readonly (vault_program , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: MeteoraSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct GoosefxSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub controller : :: solana_program :: pubkey :: Pubkey , pub pair : :: solana_program :: pubkey :: Pubkey , pub ssl_in : :: solana_program :: pubkey :: Pubkey , pub ssl_out : :: solana_program :: pubkey :: Pubkey , pub liability_vault_in : :: solana_program :: pubkey :: Pubkey , pub swapped_liability_vault_in : :: solana_program :: pubkey :: Pubkey , pub liability_vault_out : :: solana_program :: pubkey :: Pubkey , pub swapped_liability_vault_out : :: solana_program :: pubkey :: Pubkey , pub user_in_ata : :: solana_program :: pubkey :: Pubkey , pub user_out_ata : :: solana_program :: pubkey :: Pubkey , pub fee_collector_ata : :: solana_program :: pubkey :: Pubkey , pub user_wallet : :: solana_program :: pubkey :: Pubkey , pub fee_collector : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl GoosefxSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , controller , pair , ssl_in , ssl_out , liability_vault_in , swapped_liability_vault_in , liability_vault_out , swapped_liability_vault_out , user_in_ata , user_out_ata , fee_collector_ata , user_wallet , fee_collector , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (controller , false) , AccountMeta :: new (pair , false) , AccountMeta :: new (ssl_in , false) , AccountMeta :: new (ssl_out , false) , AccountMeta :: new (liability_vault_in , false) , AccountMeta :: new (swapped_liability_vault_in , false) , AccountMeta :: new (liability_vault_out , false) , AccountMeta :: new (swapped_liability_vault_out , false) , AccountMeta :: new (user_in_ata , false) , AccountMeta :: new (user_out_ata , false) , AccountMeta :: new (fee_collector_ata , false) , AccountMeta :: new_readonly (user_wallet , true) , AccountMeta :: new_readonly (fee_collector , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: GoosefxSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct DeltafiSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub market_config : :: solana_program :: pubkey :: Pubkey , pub swap_info : :: solana_program :: pubkey :: Pubkey , pub user_source_token : :: solana_program :: pubkey :: Pubkey , pub user_destination_token : :: solana_program :: pubkey :: Pubkey , pub swap_source_token : :: solana_program :: pubkey :: Pubkey , pub swap_destination_token : :: solana_program :: pubkey :: Pubkey , pub deltafi_user : :: solana_program :: pubkey :: Pubkey , pub admin_destination_token : :: solana_program :: pubkey :: Pubkey , pub pyth_price_base : :: solana_program :: pubkey :: Pubkey , pub pyth_price_quote : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl DeltafiSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , market_config , swap_info , user_source_token , user_destination_token , swap_source_token , swap_destination_token , deltafi_user , admin_destination_token , pyth_price_base , pyth_price_quote , user_authority , token_program , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (market_config , false) , AccountMeta :: new (swap_info , false) , AccountMeta :: new (user_source_token , false) , AccountMeta :: new (user_destination_token , false) , AccountMeta :: new (swap_source_token , false) , AccountMeta :: new (swap_destination_token , false) , AccountMeta :: new (deltafi_user , false) , AccountMeta :: new (admin_destination_token , false) , AccountMeta :: new_readonly (pyth_price_base , false) , AccountMeta :: new_readonly (pyth_price_quote , false) , AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: DeltafiSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct BalansolSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub tax_man : :: solana_program :: pubkey :: Pubkey , pub bid_mint : :: solana_program :: pubkey :: Pubkey , pub treasurer : :: solana_program :: pubkey :: Pubkey , pub src_treasury : :: solana_program :: pubkey :: Pubkey , pub src_associated_token_account : :: solana_program :: pubkey :: Pubkey , pub ask_mint : :: solana_program :: pubkey :: Pubkey , pub dst_treasury : :: solana_program :: pubkey :: Pubkey , pub dst_associated_token_account : :: solana_program :: pubkey :: Pubkey , pub dst_token_account_taxman : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub associated_token_program : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl BalansolSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , authority , pool , tax_man , bid_mint , treasurer , src_treasury , src_associated_token_account , ask_mint , dst_treasury , dst_associated_token_account , dst_token_account_taxman , system_program , token_program , associated_token_program , rent , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new (authority , true) , AccountMeta :: new (pool , false) , AccountMeta :: new (tax_man , false) , AccountMeta :: new_readonly (bid_mint , false) , AccountMeta :: new_readonly (treasurer , false) , AccountMeta :: new (src_treasury , false) , AccountMeta :: new (src_associated_token_account , false) , AccountMeta :: new_readonly (ask_mint , false) , AccountMeta :: new (dst_treasury , false) , AccountMeta :: new (dst_associated_token_account , false) , AccountMeta :: new (dst_token_account_taxman , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (associated_token_program , false) , AccountMeta :: new_readonly (rent , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: BalansolSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MarcoPoloSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub state : :: solana_program :: pubkey :: Pubkey , pub pool : :: solana_program :: pubkey :: Pubkey , pub token_x : :: solana_program :: pubkey :: Pubkey , pub token_y : :: solana_program :: pubkey :: Pubkey , pub pool_x_account : :: solana_program :: pubkey :: Pubkey , pub pool_y_account : :: solana_program :: pubkey :: Pubkey , pub swapper_x_account : :: solana_program :: pubkey :: Pubkey , pub swapper_y_account : :: solana_program :: pubkey :: Pubkey , pub swapper : :: solana_program :: pubkey :: Pubkey , pub referrer_x_account : :: solana_program :: pubkey :: Pubkey , pub referrer_y_account : :: solana_program :: pubkey :: Pubkey , pub referrer : :: solana_program :: pubkey :: Pubkey , pub program_authority : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub associated_token_program : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl MarcoPoloSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , state , pool , token_x , token_y , pool_x_account , pool_y_account , swapper_x_account , swapper_y_account , swapper , referrer_x_account , referrer_y_account , referrer , program_authority , system_program , token_program , associated_token_program , rent , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new_readonly (state , false) , AccountMeta :: new (pool , false) , AccountMeta :: new_readonly (token_x , false) , AccountMeta :: new_readonly (token_y , false) , AccountMeta :: new (pool_x_account , false) , AccountMeta :: new (pool_y_account , false) , AccountMeta :: new (swapper_x_account , false) , AccountMeta :: new (swapper_y_account , false) , AccountMeta :: new (swapper , true) , AccountMeta :: new (referrer_x_account , false) , AccountMeta :: new (referrer_y_account , false) , AccountMeta :: new (referrer , false) , AccountMeta :: new_readonly (program_authority , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (associated_token_program , false) , AccountMeta :: new_readonly (rent , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: MarcoPoloSwap {} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct DradexSwap {pub program_id : :: solana_program :: pubkey :: Pubkey , pub swap_program : :: solana_program :: pubkey :: Pubkey , pub pair : :: solana_program :: pubkey :: Pubkey , pub market : :: solana_program :: pubkey :: Pubkey , pub event_queue : :: solana_program :: pubkey :: Pubkey , pub dex_user : :: solana_program :: pubkey :: Pubkey , pub market_user : :: solana_program :: pubkey :: Pubkey , pub bids : :: solana_program :: pubkey :: Pubkey , pub asks : :: solana_program :: pubkey :: Pubkey , pub t0_vault : :: solana_program :: pubkey :: Pubkey , pub t1_vault : :: solana_program :: pubkey :: Pubkey , pub t0_user : :: solana_program :: pubkey :: Pubkey , pub t1_user : :: solana_program :: pubkey :: Pubkey , pub master : :: solana_program :: pubkey :: Pubkey , pub signer : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub logger : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > ,} impl DradexSwap {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , swap_program , pair , market , event_queue , dex_user , market_user , bids , asks , t0_vault , t1_vault , t0_user , t1_user , master , signer , system_program , token_program , logger , trailing_accounts ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (swap_program , false) , AccountMeta :: new (pair , false) , AccountMeta :: new (market , false) , AccountMeta :: new (event_queue , false) , AccountMeta :: new_readonly (dex_user , false) , AccountMeta :: new (market_user , false) , AccountMeta :: new (bids , false) , AccountMeta :: new (asks , false) , AccountMeta :: new (t0_vault , false) , AccountMeta :: new (t1_vault , false) , AccountMeta :: new (t0_user , false) , AccountMeta :: new (t1_user , false) , AccountMeta :: new_readonly (master , false) , AccountMeta :: new (signer , true) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (logger , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = JupiterInstruction :: DradexSwap {} . pack () ; Instruction {program_id , data , accounts ,}}}} pub mod types {# [derive (Clone , Copy , Default , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub struct AmountWithSlippage {pub amount : u64 , pub slippage_bps : u16} # [derive (Clone , Copy , Default , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub struct SplitLegDeeper {pub percent : u8 , pub swap_leg : SwapLegSwap} # [derive (Clone , Default , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub struct SplitLeg {pub percent : u8 , pub swap_leg : SwapLegDeeper} # [derive (Clone , Copy , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum SwapInstrution {Swap (Swap)} # [derive (Clone , Copy , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum Side {Bid , Ask} # [derive (Clone , Copy , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum SwapLegSwap {PlaceholderOne , PlaceholderTwo , Swap {swap : Swap}} # [derive (Clone , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum SwapLegDeeper {Chain {swap_legs : Vec < SwapLegSwap >} , Split {split_legs : Vec < SplitLegDeeper >} , Swap {swap : Swap}} # [derive (Clone , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum SwapLeg {Chain {swap_legs : Vec < SwapLegDeeper >} , Split {split_legs : Vec < SplitLeg >} , Swap {swap : Swap}} # [derive (Clone , Copy , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum Swap {Saber , SaberAddDecimalsDeposit , SaberAddDecimalsWithdraw , TokenSwap , Sencha , Step , Cropper , Raydium , Crema , Lifinity , Mercurial , Cykura , Serum {side : Side} , MarinadeDeposit , MarinadeUnstake , Aldrin {side : Side} , AldrinV2 {side : Side} , Whirlpool {a_to_b : bool} , Invariant {x_to_y : bool} , Meteora , GooseFx , DeltaFi {stable : bool} , Balansol , MarcoPolo {x_to_y : bool} , Dradex {side : Side}} # [derive (Clone , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub enum SwapAction {SetupSplit {percents : Vec < u8 >} , NextSplitLeg , MergeSplit , Swap {swap : Swap}}} pub mod error {# [allow (unused_imports)] use crate :: types :: * ; use :: num_derive :: FromPrimitive ; use :: thiserror :: Error ; use :: solana_program :: {decode_error :: DecodeError , program_error :: ProgramError} ; # [derive (Error , Clone , Copy , Debug , FromPrimitive , PartialEq , Eq)] # [repr (u32)] pub enum JupiterError {# [error ("Empty route")] EmptyRoute = 6000u32 , # [error ("Slippage tolerance exceeded")] SlippageToleranceExceeded = 6001u32 , # [error ("Invalid calculation")] InvalidCalculation = 6002u32 , # [error ("Missing platform fee account")] MissingPlatformFeeAccount = 6003u32 , # [error ("Invalid slippage")] InvalidSlippage = 6004u32 , # [error ("Not enough percent to 100")] NotEnoughPercent = 6005u32 , # [error ("In amounts stack is empty")] InAmountsStackIsEmpty = 6006u32 , # [error ("Out amounts stack is empty")] OutAmountsStackIsEmpty = 6007u32 , # [error ("Not Enough Account keys")] NotEnoughAccountKeys = 6008u32 ,} impl DecodeError < JupiterError > for JupiterError {fn type_of () -> & 'static str {"JupiterError"}} impl From < JupiterError > for ProgramError {fn from (err : JupiterError) -> Self {Self :: Custom (err as u32)}}}