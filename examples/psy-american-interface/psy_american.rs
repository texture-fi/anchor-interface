macro_rules ! gen_crate_docs {() => {concat ! (" " , "Psy American" , " v" , "0.2.6" , " program interface generated from Anchor IDL.")}} pub use anchor_interface :: prelude :: * ; pub mod instruction {# [derive (Debug)] pub enum PsyAmericanInstruction {# [doc = concat ! (" " , "Initialize a new PsyOptions market")] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer, writable]` authority"] # [doc = " 1. `[]` underlying asset mint"] # [doc = " 2. `[]` quote asset mint"] # [doc = " 3. `[writable]` option mint"] # [doc = " 4. `[writable]` writer token mint"] # [doc = " 5. `[writable]` quote asset pool"] # [doc = " 6. `[writable]` underlying asset pool"] # [doc = " 7. `[writable]` option market"] # [doc = " 8. `[]` fee owner"] # [doc = " 9. `[]` token program"] # [doc = " 10. `[]` associated token program"] # [doc = " 11. `[]` rent"] # [doc = " 12. `[]` system program"] # [doc = " 13. `[]` clock"] InitializeMarket {underlying_amount_per_contract : u64 , quote_amount_per_contract : u64 , expiration_unix_timestamp : i64 , bump_seed : u8} , # [doc = " Mint Option"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer, writable]` user authority"] # [doc = " 1. `[]` underlying asset mint"] # [doc = " 2. `[writable]` underlying asset pool"] # [doc = " 3. `[writable]` underlying asset src"] # [doc = " 4. `[writable]` option mint"] # [doc = " 5. `[writable]` minted option dest"] # [doc = " 6. `[writable]` writer token mint"] # [doc = " 7. `[writable]` minted writer token dest"] # [doc = " 8. `[]` option market"] # [doc = " 9. `[writable]` fee owner"] # [doc = " 10. `[]` token program"] # [doc = " 11. `[]` associated token program"] # [doc = " 12. `[]` clock"] # [doc = " 13. `[]` rent"] # [doc = " 14. `[]` system program"] MintOption {size : u64} , # [doc = " Mint Option V2"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer]` user authority"] # [doc = " 1. `[]` underlying asset mint"] # [doc = " 2. `[writable]` underlying asset pool"] # [doc = " 3. `[writable]` underlying asset src"] # [doc = " 4. `[writable]` option mint"] # [doc = " 5. `[writable]` minted option dest"] # [doc = " 6. `[writable]` writer token mint"] # [doc = " 7. `[writable]` minted writer token dest"] # [doc = " 8. `[]` option market"] # [doc = " 9. `[]` token program"] MintOptionV2 {size : u64} , # [doc = " Exercise Option"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer]` user authority"] # [doc = " 1. `[signer, writable]` option authority"] # [doc = " 2. `[]` option market"] # [doc = " 3. `[writable]` option mint"] # [doc = " 4. `[writable]` exerciser option token src"] # [doc = " 5. `[writable]` underlying asset pool"] # [doc = " 6. `[writable]` underlying asset dest"] # [doc = " 7. `[writable]` quote asset pool"] # [doc = " 8. `[writable]` quote asset src"] # [doc = " 9. `[writable]` fee owner"] # [doc = " 10. `[]` token program"] # [doc = " 11. `[]` system program"] # [doc = " 12. `[]` clock"] ExerciseOption {size : u64} , # [doc = " Exercise Option V2"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer]` user authority"] # [doc = " 1. `[signer]` option authority"] # [doc = " 2. `[]` option market"] # [doc = " 3. `[writable]` option mint"] # [doc = " 4. `[writable]` exerciser option token src"] # [doc = " 5. `[writable]` underlying asset pool"] # [doc = " 6. `[writable]` underlying asset dest"] # [doc = " 7. `[writable]` quote asset pool"] # [doc = " 8. `[writable]` quote asset src"] # [doc = " 9. `[]` token program"] ExerciseOptionV2 {size : u64} , # [doc = " Close Post Expiration"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer]` user authority"] # [doc = " 1. `[]` option market"] # [doc = " 2. `[writable]` writer token mint"] # [doc = " 3. `[writable]` writer token src"] # [doc = " 4. `[writable]` underlying asset pool"] # [doc = " 5. `[writable]` underlying asset dest"] # [doc = " 6. `[]` token program"] # [doc = " 7. `[]` clock"] ClosePostExpiration {size : u64} , # [doc = " Close Option Position"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer]` user authority"] # [doc = " 1. `[]` option market"] # [doc = " 2. `[writable]` writer token mint"] # [doc = " 3. `[writable]` writer token src"] # [doc = " 4. `[writable]` option token mint"] # [doc = " 5. `[writable]` option token src"] # [doc = " 6. `[writable]` underlying asset pool"] # [doc = " 7. `[writable]` underlying asset dest"] # [doc = " 8. `[]` token program"] CloseOptionPosition {size : u64} , # [doc = " Burn Writer For Quote"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer]` user authority"] # [doc = " 1. `[]` option market"] # [doc = " 2. `[writable]` writer token mint"] # [doc = " 3. `[writable]` writer token src"] # [doc = " 4. `[writable]` quote asset pool"] # [doc = " 5. `[writable]` writer quote dest"] # [doc = " 6. `[]` token program"] BurnWriterForQuote {size : u64} , # [doc = " Init Serum Market"] # [doc = " "] # [doc = " Accounts expected by this instruction:"] # [doc = " 0. `[signer, writable]` user authority"] # [doc = " 1. `[writable]` option market"] # [doc = " 2. `[writable]` serum market"] # [doc = " 3. `[]` system program"] # [doc = " 4. `[]` token program"] # [doc = " 5. `[]` dex program"] # [doc = " 6. `[]` rent"] # [doc = " 7. `[]` pc mint"] # [doc = " 8. `[]` option mint"] # [doc = " 9. `[writable]` request queue"] # [doc = " 10. `[writable]` event queue"] # [doc = " 11. `[writable]` bids"] # [doc = " 12. `[writable]` asks"] # [doc = " 13. `[writable]` coin vault"] # [doc = " 14. `[writable]` pc vault"] # [doc = " 15. `[]` vault signer"] # [doc = " 16. `[]` market authority"] InitSerumMarket {market_space : u64 , vault_signer_nonce : u64 , coin_lot_size : u64 , pc_lot_size : u64 , pc_dust_threshold : u64}} impl PsyAmericanInstruction {pub fn sighash (& self) -> & 'static [u8 ; 8] {match self {Self :: InitializeMarket {..} => & [35u8 , 35u8 , 189u8 , 193u8 , 155u8 , 48u8 , 170u8 , 203u8] , Self :: MintOption {..} => & [76u8 , 112u8 , 32u8 , 89u8 , 147u8 , 85u8 , 222u8 , 43u8] , Self :: MintOptionV2 {..} => & [229u8 , 204u8 , 221u8 , 145u8 , 212u8 , 231u8 , 30u8 , 76u8] , Self :: ExerciseOption {..} => & [231u8 , 98u8 , 131u8 , 183u8 , 245u8 , 93u8 , 122u8 , 48u8] , Self :: ExerciseOptionV2 {..} => & [122u8 , 167u8 , 194u8 , 73u8 , 152u8 , 110u8 , 30u8 , 200u8] , Self :: ClosePostExpiration {..} => & [115u8 , 203u8 , 223u8 , 108u8 , 122u8 , 150u8 , 229u8 , 92u8] , Self :: CloseOptionPosition {..} => & [225u8 , 84u8 , 101u8 , 195u8 , 235u8 , 136u8 , 55u8 , 95u8] , Self :: BurnWriterForQuote {..} => & [217u8 , 231u8 , 245u8 , 248u8 , 97u8 , 254u8 , 198u8 , 120u8] , Self :: InitSerumMarket {..} => & [55u8 , 157u8 , 44u8 , 90u8 , 69u8 , 81u8 , 148u8 , 175u8]}} pub fn pack (self) -> Vec < u8 > {use :: borsh :: BorshSerialize ; let mut out = Vec :: new () ; out . extend (self . sighash ()) ; let data = self . try_to_vec () . unwrap () ; out . extend (data) ; out} pub fn unpack (data : & [u8]) -> :: std :: io :: Result < Self > {use :: borsh :: BorshDeserialize ; let (sighash , ix_data) = data . split_at (8) ; Ok (match sighash {[35u8 , 35u8 , 189u8 , 193u8 , 155u8 , 48u8 , 170u8 , 203u8] => {InitializeMarketDeserializer :: try_from_slice (ix_data) ? . into ()} [76u8 , 112u8 , 32u8 , 89u8 , 147u8 , 85u8 , 222u8 , 43u8] => {MintOptionDeserializer :: try_from_slice (ix_data) ? . into ()} [229u8 , 204u8 , 221u8 , 145u8 , 212u8 , 231u8 , 30u8 , 76u8] => {MintOptionV2Deserializer :: try_from_slice (ix_data) ? . into ()} [231u8 , 98u8 , 131u8 , 183u8 , 245u8 , 93u8 , 122u8 , 48u8] => {ExerciseOptionDeserializer :: try_from_slice (ix_data) ? . into ()} [122u8 , 167u8 , 194u8 , 73u8 , 152u8 , 110u8 , 30u8 , 200u8] => {ExerciseOptionV2Deserializer :: try_from_slice (ix_data) ? . into ()} [115u8 , 203u8 , 223u8 , 108u8 , 122u8 , 150u8 , 229u8 , 92u8] => {ClosePostExpirationDeserializer :: try_from_slice (ix_data) ? . into ()} [225u8 , 84u8 , 101u8 , 195u8 , 235u8 , 136u8 , 55u8 , 95u8] => {CloseOptionPositionDeserializer :: try_from_slice (ix_data) ? . into ()} [217u8 , 231u8 , 245u8 , 248u8 , 97u8 , 254u8 , 198u8 , 120u8] => {BurnWriterForQuoteDeserializer :: try_from_slice (ix_data) ? . into ()} [55u8 , 157u8 , 44u8 , 90u8 , 69u8 , 81u8 , 148u8 , 175u8] => {InitSerumMarketDeserializer :: try_from_slice (ix_data) ? . into ()} _ => return Err (std :: io :: Error :: new (std :: io :: ErrorKind :: InvalidInput , "invalid sighash" ,)) ,})}} impl :: borsh :: BorshSerialize for PsyAmericanInstruction {fn serialize < W : :: borsh :: maybestd :: io :: Write > (& self , writer : & mut W ,) -> :: core :: result :: Result < () , :: borsh :: maybestd :: io :: Error > {match self {Self :: InitializeMarket {underlying_amount_per_contract , quote_amount_per_contract , expiration_unix_timestamp , bump_seed} => {:: borsh :: BorshSerialize :: serialize (underlying_amount_per_contract , writer) ? ; :: borsh :: BorshSerialize :: serialize (quote_amount_per_contract , writer) ? ; :: borsh :: BorshSerialize :: serialize (expiration_unix_timestamp , writer) ? ; :: borsh :: BorshSerialize :: serialize (bump_seed , writer) ? ;} Self :: MintOption {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: MintOptionV2 {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: ExerciseOption {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: ExerciseOptionV2 {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: ClosePostExpiration {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: CloseOptionPosition {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: BurnWriterForQuote {size} => {:: borsh :: BorshSerialize :: serialize (size , writer) ? ;} Self :: InitSerumMarket {market_space , vault_signer_nonce , coin_lot_size , pc_lot_size , pc_dust_threshold} => {:: borsh :: BorshSerialize :: serialize (market_space , writer) ? ; :: borsh :: BorshSerialize :: serialize (vault_signer_nonce , writer) ? ; :: borsh :: BorshSerialize :: serialize (coin_lot_size , writer) ? ; :: borsh :: BorshSerialize :: serialize (pc_lot_size , writer) ? ; :: borsh :: BorshSerialize :: serialize (pc_dust_threshold , writer) ? ;}} Ok (())}} struct InitializeMarketDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for InitializeMarketDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: InitializeMarket {underlying_amount_per_contract : :: borsh :: BorshDeserialize :: deserialize (buf) ? , quote_amount_per_contract : :: borsh :: BorshDeserialize :: deserialize (buf) ? , expiration_unix_timestamp : :: borsh :: BorshDeserialize :: deserialize (buf) ? , bump_seed : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < InitializeMarketDeserializer > for PsyAmericanInstruction {fn from (helper : InitializeMarketDeserializer) -> PsyAmericanInstruction {helper . 0}} struct MintOptionDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for MintOptionDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: MintOption {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < MintOptionDeserializer > for PsyAmericanInstruction {fn from (helper : MintOptionDeserializer) -> PsyAmericanInstruction {helper . 0}} struct MintOptionV2Deserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for MintOptionV2Deserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: MintOptionV2 {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < MintOptionV2Deserializer > for PsyAmericanInstruction {fn from (helper : MintOptionV2Deserializer) -> PsyAmericanInstruction {helper . 0}} struct ExerciseOptionDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for ExerciseOptionDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: ExerciseOption {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < ExerciseOptionDeserializer > for PsyAmericanInstruction {fn from (helper : ExerciseOptionDeserializer) -> PsyAmericanInstruction {helper . 0}} struct ExerciseOptionV2Deserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for ExerciseOptionV2Deserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: ExerciseOptionV2 {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < ExerciseOptionV2Deserializer > for PsyAmericanInstruction {fn from (helper : ExerciseOptionV2Deserializer) -> PsyAmericanInstruction {helper . 0}} struct ClosePostExpirationDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for ClosePostExpirationDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: ClosePostExpiration {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < ClosePostExpirationDeserializer > for PsyAmericanInstruction {fn from (helper : ClosePostExpirationDeserializer) -> PsyAmericanInstruction {helper . 0}} struct CloseOptionPositionDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for CloseOptionPositionDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: CloseOptionPosition {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < CloseOptionPositionDeserializer > for PsyAmericanInstruction {fn from (helper : CloseOptionPositionDeserializer) -> PsyAmericanInstruction {helper . 0}} struct BurnWriterForQuoteDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for BurnWriterForQuoteDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: BurnWriterForQuote {size : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < BurnWriterForQuoteDeserializer > for PsyAmericanInstruction {fn from (helper : BurnWriterForQuoteDeserializer) -> PsyAmericanInstruction {helper . 0}} struct InitSerumMarketDeserializer (PsyAmericanInstruction) ; impl :: borsh :: de :: BorshDeserialize for InitSerumMarketDeserializer {fn deserialize (buf : & mut & [u8] ,) -> :: core :: result :: Result < Self , :: borsh :: maybestd :: io :: Error > {Ok (Self (PsyAmericanInstruction :: InitSerumMarket {market_space : :: borsh :: BorshDeserialize :: deserialize (buf) ? , vault_signer_nonce : :: borsh :: BorshDeserialize :: deserialize (buf) ? , coin_lot_size : :: borsh :: BorshDeserialize :: deserialize (buf) ? , pc_lot_size : :: borsh :: BorshDeserialize :: deserialize (buf) ? , pc_dust_threshold : :: borsh :: BorshDeserialize :: deserialize (buf) ? ,}))}} impl From < InitSerumMarketDeserializer > for PsyAmericanInstruction {fn from (helper : InitSerumMarketDeserializer) -> PsyAmericanInstruction {helper . 0}} # [derive (Debug)] pub struct InitializeMarket {pub program_id : :: solana_program :: pubkey :: Pubkey , pub authority : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_mint : :: solana_program :: pubkey :: Pubkey , pub quote_asset_mint : :: solana_program :: pubkey :: Pubkey , pub option_mint : :: solana_program :: pubkey :: Pubkey , pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , pub quote_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub fee_owner : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub associated_token_program : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub clock : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub underlying_amount_per_contract : u64 , pub quote_amount_per_contract : u64 , pub expiration_unix_timestamp : i64 , pub bump_seed : u8 ,} impl InitializeMarket {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , authority , underlying_asset_mint , quote_asset_mint , option_mint , writer_token_mint , quote_asset_pool , underlying_asset_pool , option_market , fee_owner , token_program , associated_token_program , rent , system_program , clock , trailing_accounts , underlying_amount_per_contract , quote_amount_per_contract , expiration_unix_timestamp , bump_seed ,} = self ; let mut accounts = vec ! [AccountMeta :: new (authority , true) , AccountMeta :: new_readonly (underlying_asset_mint , false) , AccountMeta :: new_readonly (quote_asset_mint , false) , AccountMeta :: new (option_mint , false) , AccountMeta :: new (writer_token_mint , false) , AccountMeta :: new (quote_asset_pool , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (option_market , false) , AccountMeta :: new_readonly (fee_owner , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (associated_token_program , false) , AccountMeta :: new_readonly (rent , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (clock , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: InitializeMarket {underlying_amount_per_contract , quote_amount_per_contract , expiration_unix_timestamp , bump_seed ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MintOption {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_mint : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_src : :: solana_program :: pubkey :: Pubkey , pub option_mint : :: solana_program :: pubkey :: Pubkey , pub minted_option_dest : :: solana_program :: pubkey :: Pubkey , pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , pub minted_writer_token_dest : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub fee_owner : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub associated_token_program : :: solana_program :: pubkey :: Pubkey , pub clock : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl MintOption {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , underlying_asset_mint , underlying_asset_pool , underlying_asset_src , option_mint , minted_option_dest , writer_token_mint , minted_writer_token_dest , option_market , fee_owner , token_program , associated_token_program , clock , rent , system_program , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new (user_authority , true) , AccountMeta :: new_readonly (underlying_asset_mint , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (underlying_asset_src , false) , AccountMeta :: new (option_mint , false) , AccountMeta :: new (minted_option_dest , false) , AccountMeta :: new (writer_token_mint , false) , AccountMeta :: new (minted_writer_token_dest , false) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new (fee_owner , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (associated_token_program , false) , AccountMeta :: new_readonly (clock , false) , AccountMeta :: new_readonly (rent , false) , AccountMeta :: new_readonly (system_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: MintOption {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct MintOptionV2 {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_mint : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_src : :: solana_program :: pubkey :: Pubkey , pub option_mint : :: solana_program :: pubkey :: Pubkey , pub minted_option_dest : :: solana_program :: pubkey :: Pubkey , pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , pub minted_writer_token_dest : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl MintOptionV2 {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , underlying_asset_mint , underlying_asset_pool , underlying_asset_src , option_mint , minted_option_dest , writer_token_mint , minted_writer_token_dest , option_market , token_program , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new_readonly (underlying_asset_mint , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (underlying_asset_src , false) , AccountMeta :: new (option_mint , false) , AccountMeta :: new (minted_option_dest , false) , AccountMeta :: new (writer_token_mint , false) , AccountMeta :: new (minted_writer_token_dest , false) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: MintOptionV2 {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct ExerciseOption {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub option_authority : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub option_mint : :: solana_program :: pubkey :: Pubkey , pub exerciser_option_token_src : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_dest : :: solana_program :: pubkey :: Pubkey , pub quote_asset_pool : :: solana_program :: pubkey :: Pubkey , pub quote_asset_src : :: solana_program :: pubkey :: Pubkey , pub fee_owner : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub clock : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl ExerciseOption {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , option_authority , option_market , option_mint , exerciser_option_token_src , underlying_asset_pool , underlying_asset_dest , quote_asset_pool , quote_asset_src , fee_owner , token_program , system_program , clock , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new (option_authority , true) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new (option_mint , false) , AccountMeta :: new (exerciser_option_token_src , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (underlying_asset_dest , false) , AccountMeta :: new (quote_asset_pool , false) , AccountMeta :: new (quote_asset_src , false) , AccountMeta :: new (fee_owner , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (clock , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: ExerciseOption {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct ExerciseOptionV2 {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub option_authority : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub option_mint : :: solana_program :: pubkey :: Pubkey , pub exerciser_option_token_src : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_dest : :: solana_program :: pubkey :: Pubkey , pub quote_asset_pool : :: solana_program :: pubkey :: Pubkey , pub quote_asset_src : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl ExerciseOptionV2 {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , option_authority , option_market , option_mint , exerciser_option_token_src , underlying_asset_pool , underlying_asset_dest , quote_asset_pool , quote_asset_src , token_program , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new_readonly (option_authority , true) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new (option_mint , false) , AccountMeta :: new (exerciser_option_token_src , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (underlying_asset_dest , false) , AccountMeta :: new (quote_asset_pool , false) , AccountMeta :: new (quote_asset_src , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: ExerciseOptionV2 {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct ClosePostExpiration {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , pub writer_token_src : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_dest : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub clock : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl ClosePostExpiration {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , option_market , writer_token_mint , writer_token_src , underlying_asset_pool , underlying_asset_dest , token_program , clock , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new (writer_token_mint , false) , AccountMeta :: new (writer_token_src , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (underlying_asset_dest , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (clock , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: ClosePostExpiration {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct CloseOptionPosition {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , pub writer_token_src : :: solana_program :: pubkey :: Pubkey , pub option_token_mint : :: solana_program :: pubkey :: Pubkey , pub option_token_src : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , pub underlying_asset_dest : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl CloseOptionPosition {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , option_market , writer_token_mint , writer_token_src , option_token_mint , option_token_src , underlying_asset_pool , underlying_asset_dest , token_program , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new (writer_token_mint , false) , AccountMeta :: new (writer_token_src , false) , AccountMeta :: new (option_token_mint , false) , AccountMeta :: new (option_token_src , false) , AccountMeta :: new (underlying_asset_pool , false) , AccountMeta :: new (underlying_asset_dest , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: CloseOptionPosition {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct BurnWriterForQuote {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , pub writer_token_src : :: solana_program :: pubkey :: Pubkey , pub quote_asset_pool : :: solana_program :: pubkey :: Pubkey , pub writer_quote_dest : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub size : u64 ,} impl BurnWriterForQuote {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , option_market , writer_token_mint , writer_token_src , quote_asset_pool , writer_quote_dest , token_program , trailing_accounts , size ,} = self ; let mut accounts = vec ! [AccountMeta :: new_readonly (user_authority , true) , AccountMeta :: new_readonly (option_market , false) , AccountMeta :: new (writer_token_mint , false) , AccountMeta :: new (writer_token_src , false) , AccountMeta :: new (quote_asset_pool , false) , AccountMeta :: new (writer_quote_dest , false) , AccountMeta :: new_readonly (token_program , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: BurnWriterForQuote {size ,} . pack () ; Instruction {program_id , data , accounts ,}}} # [derive (Debug)] pub struct InitSerumMarket {pub program_id : :: solana_program :: pubkey :: Pubkey , pub user_authority : :: solana_program :: pubkey :: Pubkey , pub option_market : :: solana_program :: pubkey :: Pubkey , pub serum_market : :: solana_program :: pubkey :: Pubkey , pub system_program : :: solana_program :: pubkey :: Pubkey , pub token_program : :: solana_program :: pubkey :: Pubkey , pub dex_program : :: solana_program :: pubkey :: Pubkey , pub rent : :: solana_program :: pubkey :: Pubkey , pub pc_mint : :: solana_program :: pubkey :: Pubkey , pub option_mint : :: solana_program :: pubkey :: Pubkey , pub request_queue : :: solana_program :: pubkey :: Pubkey , pub event_queue : :: solana_program :: pubkey :: Pubkey , pub bids : :: solana_program :: pubkey :: Pubkey , pub asks : :: solana_program :: pubkey :: Pubkey , pub coin_vault : :: solana_program :: pubkey :: Pubkey , pub pc_vault : :: solana_program :: pubkey :: Pubkey , pub vault_signer : :: solana_program :: pubkey :: Pubkey , pub market_authority : :: solana_program :: pubkey :: Pubkey , pub trailing_accounts : Vec < :: solana_program :: instruction :: AccountMeta > , pub market_space : u64 , pub vault_signer_nonce : u64 , pub coin_lot_size : u64 , pub pc_lot_size : u64 , pub pc_dust_threshold : u64 ,} impl InitSerumMarket {pub fn into_instruction (self) -> :: solana_program :: instruction :: Instruction {use :: solana_program :: instruction :: {AccountMeta , Instruction} ; let Self {program_id , user_authority , option_market , serum_market , system_program , token_program , dex_program , rent , pc_mint , option_mint , request_queue , event_queue , bids , asks , coin_vault , pc_vault , vault_signer , market_authority , trailing_accounts , market_space , vault_signer_nonce , coin_lot_size , pc_lot_size , pc_dust_threshold ,} = self ; let mut accounts = vec ! [AccountMeta :: new (user_authority , true) , AccountMeta :: new (option_market , false) , AccountMeta :: new (serum_market , false) , AccountMeta :: new_readonly (system_program , false) , AccountMeta :: new_readonly (token_program , false) , AccountMeta :: new_readonly (dex_program , false) , AccountMeta :: new_readonly (rent , false) , AccountMeta :: new_readonly (pc_mint , false) , AccountMeta :: new_readonly (option_mint , false) , AccountMeta :: new (request_queue , false) , AccountMeta :: new (event_queue , false) , AccountMeta :: new (bids , false) , AccountMeta :: new (asks , false) , AccountMeta :: new (coin_vault , false) , AccountMeta :: new (pc_vault , false) , AccountMeta :: new_readonly (vault_signer , false) , AccountMeta :: new_readonly (market_authority , false) ,] ; if ! trailing_accounts . is_empty () {accounts . extend (trailing_accounts) ;} let data = PsyAmericanInstruction :: InitSerumMarket {market_space , vault_signer_nonce , coin_lot_size , pc_lot_size , pc_dust_threshold ,} . pack () ; Instruction {program_id , data , accounts ,}}}} pub mod state {# [doc = concat ! (" " , "Data structure that contains all the information needed to maintain an open")] # [doc = concat ! (" " , "option market.")] # [derive (Clone , Copy , Default , :: borsh :: BorshDeserialize , :: borsh :: BorshSerialize)] # [derive (Debug)] pub struct OptionMarket {# [doc = concat ! (" " , "The SPL Token mint address for the tokens that denote an option")] pub option_mint : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "The SPL Token mint address for Writer Tokens that denote a written option")] pub writer_token_mint : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "The SPL Token Address that is held in the program\'s pool when an option is written")] pub underlying_asset_mint : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "The SPL Token Address that denominates the strike price")] pub quote_asset_mint : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "The amount of the **underlying asset** that derives a single option")] pub underlying_amount_per_contract : u64 , # [doc = concat ! (" " , "The amount of **quote asset** that must be transfered when an option is exercised")] pub quote_amount_per_contract : u64 , # [doc = concat ! (" " , "The Unix timestamp at which the contracts in this market expire")] pub expiration_unix_timestamp : i64 , # [doc = concat ! (" " , "Address for the liquidity pool that contains the underlying assset")] pub underlying_asset_pool : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "Address for the liquidity pool that contains the quote asset when")] # [doc = concat ! (" " , "options are exercised")] pub quote_asset_pool : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "The SPL Token account (from the Associated Token Program) that collects")] # [doc = concat ! (" " , "fees on mint.")] pub mint_fee_account : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "The SPL Token account (from the Associated Token Program) that collects")] # [doc = concat ! (" " , "fees on exercise.")] pub exercise_fee_account : :: solana_program :: pubkey :: Pubkey , # [doc = concat ! (" " , "A flag to set and use to when running a memcmp query.")] # [doc = concat ! (" " , "This will be set when Serum markets are closed and expiration is validated")] pub expired : bool , # [doc = concat ! (" " , "Bump seed for the market PDA")] pub bump_seed : u8} impl :: anchor_interface :: Account for OptionMarket {fn discriminator () -> & 'static [u8 ; 8] {& [175u8 , 238u8 , 162u8 , 97u8 , 53u8 , 122u8 , 16u8 , 29u8]}} impl :: anchor_interface :: AccountSerialize for OptionMarket {fn try_serialize < W : std :: io :: Write > (& self , writer : & mut W) -> std :: io :: Result < () > {use :: anchor_interface :: Account ; writer . write_all (Self :: discriminator ()) ? ; :: borsh :: BorshSerialize :: serialize (self , writer) ? ; Ok (())}} impl :: anchor_interface :: AccountDeserialize for OptionMarket {fn try_deserialize (data : & mut & [u8]) -> std :: io :: Result < Self > {use :: anchor_interface :: Account ; if data . len () < 8 || & data [.. 8] != Self :: discriminator () {return Err (std :: io :: Error :: new (std :: io :: ErrorKind :: InvalidData , "invalid discriminator" ,)) ;} let t = :: borsh :: BorshDeserialize :: try_from_slice (& data [8 ..]) ? ; Ok (t)}}} pub mod error {use :: num_derive :: FromPrimitive ; use :: thiserror :: Error ; use :: solana_program :: {decode_error :: DecodeError , program_error :: ProgramError} ; # [derive (Error , Clone , Copy , Debug , FromPrimitive , PartialEq , Eq)] # [repr (u32)] pub enum PsyAmericanError {# [error ("Expiration must be in the future")] ExpirationIsInThePast = 6000u32 , # [error ("Same quote and underlying asset, cannot create market")] QuoteAndUnderlyingAssetMustDiffer = 6001u32 , # [error ("Quote amount and underlying amount per contract must be > 0")] QuoteOrUnderlyingAmountCannotBe0 = 6002u32 , # [error ("OptionMarket must be the mint authority")] OptionMarketMustBeMintAuthority = 6003u32 , # [error ("OptionMarket must own the underlying asset pool")] OptionMarketMustOwnUnderlyingAssetPool = 6004u32 , # [error ("OptionMarket must own the quote asset pool")] OptionMarketMustOwnQuoteAssetPool = 6005u32 , # [error ("Stop trying to spoof the SPL Token program! Shame on you")] ExpectedSplTokenProgramId = 6006u32 , # [error ("Mint fee account must be owned by the FEE_OWNER")] MintFeeMustBeOwnedByFeeOwner = 6007u32 , # [error ("Exercise fee account must be owned by the FEE_OWNER")] ExerciseFeeMustBeOwnedByFeeOwner = 6008u32 , # [error ("Mint fee token must be the same as the underlying asset")] MintFeeTokenMustMatchUnderlyingAsset = 6009u32 , # [error ("Exercise fee token must be the same as the quote asset")] ExerciseFeeTokenMustMatchQuoteAsset = 6010u32 , # [error ("OptionMarket is expired, can\'t mint")] OptionMarketExpiredCantMint = 6011u32 , # [error ("Underlying pool account does not match the value on the OptionMarket")] UnderlyingPoolAccountDoesNotMatchMarket = 6012u32 , # [error ("OptionToken mint does not match the value on the OptionMarket")] OptionTokenMintDoesNotMatchMarket = 6013u32 , # [error ("WriterToken mint does not match the value on the OptionMarket")] WriterTokenMintDoesNotMatchMarket = 6014u32 , # [error ("MintFee key does not match the value on the OptionMarket")] MintFeeKeyDoesNotMatchOptionMarket = 6015u32 , # [error ("The size argument must be > 0")] SizeCantBeLessThanEqZero = 6016u32 , # [error ("exerciseFee key does not match the value on the OptionMarket")] ExerciseFeeKeyDoesNotMatchOptionMarket = 6017u32 , # [error ("Quote pool account does not match the value on the OptionMarket")] QuotePoolAccountDoesNotMatchMarket = 6018u32 , # [error ("Underlying destination mint must match underlying asset mint address")] UnderlyingDestMintDoesNotMatchUnderlyingAsset = 6019u32 , # [error ("Fee owner does not match the program\'s fee owner")] FeeOwnerDoesNotMatchProgram = 6020u32 , # [error ("OptionMarket is expired, can\'t exercise")] OptionMarketExpiredCantExercise = 6021u32 , # [error ("OptionMarket has not expired, can\'t close")] OptionMarketNotExpiredCantClose = 6022u32 , # [error ("Not enough assets in the quote asset pool")] NotEnoughQuoteAssetsInPool = 6023u32 , # [error ("Invalid auth token provided")] InvalidAuth = 6024u32 , # [error ("Coin mint must match option mint")] CoinMintIsNotOptionMint = 6025u32 , # [error ("Cannot prune the market while it\'s still active")] CannotPruneActiveMarket = 6026u32 , # [error ("Numberical overflow")] NumberOverflow = 6027u32 ,} impl DecodeError < PsyAmericanError > for PsyAmericanError {fn type_of () -> & 'static str {"PsyAmericanError"}} impl From < PsyAmericanError > for ProgramError {fn from (err : PsyAmericanError) -> Self {Self :: Custom (err as u32)}}}